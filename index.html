<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TowerStory</title>
  <style>
    html, body { height:100%; width:100%; margin:0; padding:0; background: url('assets/images/background.png') center/cover no-repeat; }
    body { display:grid; grid-template-rows:80px auto 60px; grid-template-columns:200px auto 200px;
      grid-template-areas:"header header header" "sidebar-left main sidebar-right" "footer footer footer";
      align-items:center; justify-items:center; }
    #header{grid-area:header;} #sidebar-left{grid-area:sidebar-left;} #sidebar-right{grid-area:sidebar-right;} #footer{grid-area:footer;}
    #game-container{grid-area:main; display:flex; align-items:center; justify-content:center; width:100%; height:100%; overflow:hidden;}
    #game-container canvas{max-width:100%; max-height:100%;}
  </style>
</head>
<body>
  <div id="header"></div>
  <div id="sidebar-left"></div>
  <div id="game-container"></div>
  <div id="sidebar-right"></div>
  <div id="footer"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    window.addEventListener('load', () => {
      class BootScene extends Phaser.Scene {
        constructor() { super('Boot'); }
        create() { this.scene.start('Preload'); }
      }

      class PreloadScene extends Phaser.Scene {
        constructor() { super('Preload'); }
        preload() {
          // Load map, tiles, player, and object/NPC sprites
          this.load.tilemapTiledJSON('room', 'assets/maps/room.json');
          this.load.spritesheet('tileset', 'assets/tiles/tileset.png', { frameWidth:38, frameHeight:38 });
          this.load.spritesheet('player', 'assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png', { frameWidth:32, frameHeight:32 });
          this.load.image('chest', 'assets/objects/chest.png');
          this.load.image('npc', 'assets/objects/npc.png');
        }
        create() { this.scene.start('Main'); }
      }

      class MainScene extends Phaser.Scene {
        constructor() { super('Main'); }
        create() {
          const map = this.make.tilemap({ key: 'room' });
          this.tileW = map.tileWidth; this.tileH = map.tileHeight;
          this.mapW = map.width; this.mapH = map.height;
          map.addTilesetImage('tileset','tileset',this.tileW,this.tileH);

          // Render floor tiles
          this.offsetX = this.scale.width/2;
          this.offsetY = (this.scale.height - (this.mapW + this.mapH)*this.tileH/2)/2 + this.tileH/2;
          this.floorData = map.getLayer('Floor').data.map(r=>r.map(t=>!!t&&t.index>0));
          this.collisionData = map.getLayer('Collision').data.map(r=>r.map(t=>!!t&&t.index>0));
          this.floorGroup = this.add.group();
          map.getLayer('Floor').data.forEach((row,y)=>{
            row.forEach((t,x)=>{
              if(t.index>0){
                const frame=t.index-1;
                const sx=(x-y)*this.tileW/2+this.offsetX;
                const sy=(x+y)*this.tileH/2+this.offsetY;
                this.floorGroup.add(this.add.sprite(sx,sy,'tileset',frame).setDepth(sy));
              }
            });
          });

          // Interactive objects and NPC group
          this.objectsGroup = this.add.group();
          this.npcGroup = this.add.group();
          const objectLayer = map.getObjectLayer('Objects');
          objectLayer.objects.forEach(obj=>{
            const isoX = obj.x/this.tileW;
            const isoY = obj.y/this.tileH;
            const sx=(isoX-isoY)*this.tileW/2+this.offsetX;
            const sy=(isoX+isoY)*this.tileH/2+this.offsetY;
            if(obj.type==='Chest'){
              const chest = this.add.image(sx,sy,'chest').setOrigin(0.5,1).setDepth(sy);
              chest.setInteractive();
              chest.on('pointerdown',()=> console.log('Chest opened!'));
              this.objectsGroup.add(chest);
            } else if(obj.type==='NPC'){
              const npc = this.add.sprite(sx,sy,'npc').setOrigin(0.5,1).setDepth(sy);
              this.npcGroup.add(npc);
            }
          });

          // Player spawn and animations
          const spawn=map.findObject('Objects',o=>o.name==='PlayerSpawn');
          this.playerIsoX=spawn.x/this.tileW; this.playerIsoY=spawn.y/this.tileH;
          this.player=this.add.sprite(0,0,'player').setOrigin(0.5,1);
          this.createPlayerAnims();
          this.updatePlayerPosition();

          // Input and camera
          this.keys=this.input.keyboard.addKeys('W,A,S,D');
          this.cameras.main.setBounds(0,0,map.widthInPixels,map.heightInPixels);
          this.cameras.main.startFollow(this.player,true,0.1,0.1);
        }
        update(time,delta){
          const dt=delta/1000,spd=3;let moved=false,dir=this.lastDir||'down';
          let nx=this.playerIsoX,ny=this.playerIsoY;
          const {W,A,S,D}=this.keys;
          if(W.isDown){ny-=spd*dt;dir='up';moved=true;this.player.play('walk-up',true);}
          else if(S.isDown){ny+=spd*dt;dir='down';moved=true;this.player.play('walk-down',true);}
          if(A.isDown){nx-=spd*dt;dir='left';moved=true;this.player.play('walk-left',true);}
          else if(D.isDown){nx+=spd*dt;dir='right';moved=true;this.player.play('walk-right',true);}
          // collision
          if(nx>=0&&nx<this.mapW&&ny>=0&&ny<this.mapH){const tx=Math.floor(nx),ty=Math.floor(ny);
            if(this.floorData[ty][tx]&&!this.collisionData[ty][tx]){this.playerIsoX=nx;this.playerIsoY=ny;}}
          if(!moved){this.player.anims.stop();this.player.setFrame({down:0,left:12,right:24,up:36}[dir]);}
          this.lastDir=dir;this.updatePlayerPosition();
        }
        createPlayerAnims(){[['down',0,3],['left',12,15],['right',24,27],['up',36,39],
          ['down-left',48,51],['down-right',60,63],['up-left',72,75],['up-right',84,87]
        ].forEach(([k,s,e])=>this.anims.create({key:`walk-${k}`,frames:this.anims.generateFrameNumbers('player',{start:s,end:e}),frameRate:8,repeat:-1}));}
        updatePlayerPosition(){const x=this.playerIsoX,y=this.playerIsoY;
          const sx=(x-y)*this.tileW/2+this.offsetX,sy=(x+y)*this.tileH/2+this.offsetY;
          this.player.setPosition(sx,sy).setDepth(sy);
        }
      }
      const config={type:Phaser.AUTO,parent:'game-container',scale:{mode:Phaser.Scale.FIT,autoCenter:Phaser.Scale.CENTER_BOTH},physics:{default:'arcade'},scene:[BootScene,PreloadScene,MainScene]};
      new Phaser.Game(config);
    });
  </script>
</body>
</html>
