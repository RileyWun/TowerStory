<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TowerStory</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #1d212d;
    }
    #game-container {
      width: 100%;
      height: 100%;
    }
    #game-container canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <!-- Phaser 3 -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>

  <script>
    window.addEventListener('load', () => {
      // === Boot Scene ===
      class BootScene extends Phaser.Scene {
        constructor() { super('Boot'); }
        preload() {}
        create() { this.scene.start('Preload'); }
      }

      // === Preload Scene ===
      class PreloadScene extends Phaser.Scene {
        constructor() { super('Preload'); }
        preload() {
          this.load.image('tile', 'assets/tiles/tile.png');
          this.load.spritesheet('player', 'assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png', { frameWidth: 32, frameHeight: 32 });
        }
        create() { this.scene.start('Main'); }
      }

      // === Main Scene with Diagonal Animations ===
      class MainScene extends Phaser.Scene {
        constructor() { super('Main'); }

        create() {
          // Tile and map settings
          this.tileW = 38; this.tileH = 38;
          this.mapW = 20; this.mapH = 20;

          // Offsets based on dynamic scale
          this.offsetX = this.scale.width / 2;
          // Position map so its bottom edge aligns near bottom of viewport
          this.offsetY = this.scale.height - (this.mapH * this.tileH) / 2;

          // Create isometric grid
          this.tilesGroup = this.add.group();
          for (let x = 0; x < this.mapW; x++) {
            for (let y = 0; y < this.mapH; y++) {
              const sx = (x - y) * (this.tileW / 2) + this.offsetX;
              const sy = (x + y) * (this.tileH / 2) + this.offsetY;
              const tile = this.add.image(sx, sy, 'tile');
              tile.setDepth(sy);
              this.tilesGroup.add(tile);
            }
          }

          // Player ISO coordinates
          this.playerIsoX = this.mapW / 2;
          this.playerIsoY = this.mapH / 2;

          // Create player sprite
          this.player = this.add.sprite(0, 0, 'player');
          this.player.setOrigin(0.5, 1);

          // Define animations
          this.anims.create({ key: 'walk-down',       frames: this.anims.generateFrameNumbers('player', { start: 0,   end: 3 }),   frameRate: 8, repeat: -1 });
          this.anims.create({ key: 'walk-left',       frames: this.anims.generateFrameNumbers('player', { start: 12,  end: 15 }),  frameRate: 8, repeat: -1 });
          this.anims.create({ key: 'walk-right',      frames: this.anims.generateFrameNumbers('player', { start: 24,  end: 27 }),  frameRate: 8, repeat: -1 });
          this.anims.create({ key: 'walk-up',         frames: this.anims.generateFrameNumbers('player', { start: 36,  end: 39 }),  frameRate: 8, repeat: -1 });
          this.anims.create({ key: 'walk-down-left',  frames: this.anims.generateFrameNumbers('player', { start: 48,  end: 51 }),  frameRate: 8, repeat: -1 });
          this.anims.create({ key: 'walk-down-right', frames: this.anims.generateFrameNumbers('player', { start: 60,  end: 63 }),  frameRate: 8, repeat: -1 });
          this.anims.create({ key: 'walk-up-left',    frames: this.anims.generateFrameNumbers('player', { start: 72,  end: 75 }),  frameRate: 8, repeat: -1 });
          this.anims.create({ key: 'walk-up-right',   frames: this.anims.generateFrameNumbers('player', { start: 84,  end: 87 }),  frameRate: 8, repeat: -1 });

          // Input keys
          this.keys = this.input.keyboard.addKeys('W,A,S,D');

          // Camera follow with vertical offset
          const cam = this.cameras.main;
          cam.setBounds(0, 0, this.mapW * this.tileW, this.mapH * this.tileH);
          cam.startFollow(this.player, true, 0.1, 0.1, 0, -this.tileH * 2);

          // Initial placement
          this.updatePlayerPosition();
        }

        update(time, delta) {
          const dt = delta / 1000;
          const speed = 3;
          const diag = speed / Math.SQRT2;
          let moved = false;
          let dir = this.lastDir || 'down';
          const { W, A, S, D } = this.keys;

          // Diagonal movement
          if (S.isDown && A.isDown) {
            this.playerIsoX -= diag * dt;
            this.playerIsoY += diag * dt;
            this.player.play('walk-down-left', true);
            dir = 'down-left'; moved = true;
          } else if (S.isDown && D.isDown) {
            this.playerIsoX += diag * dt;
            this.playerIsoY += diag * dt;
            this.player.play('walk-down-right', true);
            dir = 'down-right'; moved = true;
          } else if (W.isDown && A.isDown) {
            this.playerIsoX -= diag * dt;
            this.playerIsoY -= diag * dt;
            this.player.play('walk-up-left', true);
            dir = 'up-left'; moved = true;
          } else if (W.isDown && D.isDown) {
            this.playerIsoX += diag * dt;
            this.playerIsoY -= diag * dt;
            this.player.play('walk-up-right', true);
            dir = 'up-right'; moved = true;
          } else if (A.isDown) {
            this.playerIsoX -= speed * dt;
            this.player.play('walk-left', true);
            dir = 'left'; moved = true;
          } else if (D.isDown) {
            this.playerIsoX += speed * dt;
            this.player.play('walk-right', true);
            dir = 'right'; moved = true;
          } else if (W.isDown) {
            this.playerIsoY -= speed * dt;
            this.player.play('walk-up', true);
            dir = 'up'; moved = true;
          } else if (S.isDown) {
            this.playerIsoY += speed * dt;
            this.player.play('walk-down', true);
            dir = 'down'; moved = true;
          }

          // Idle frame
          if (!moved) {
            this.player.anims.stop();
            const idle = {
              down: 0, left: 12, right: 24, up: 36,
              'down-left': 48, 'down-right': 60,
              'up-left': 72, 'up-right': 84
            };
            this.player.setFrame(idle[dir]);
          }
          this.lastDir = dir;

          // Clamp to map
          this.playerIsoX = Phaser.Math.Clamp(this.playerIsoX, 0, this.mapW - 1);
          this.playerIsoY = Phaser.Math.Clamp(this.playerIsoY, 0, this.mapH - 1);

          // Update position
          this.updatePlayerPosition();
        }

        updatePlayerPosition() {
          const x = this.playerIsoX, y = this.playerIsoY;
          const sx = (x - y) * (this.tileW / 2) + this.offsetX;
          const sy = (x + y) * (this.tileH / 2) + this.offsetY;
          this.player.setPosition(sx, sy);
          this.player.setDepth(sy);
        }
      }

      // === Game Configuration ===
      const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        scale: {
          mode: Phaser.Scale.RESIZE,
          autoCenter: Phaser.Scale.CENTER_BOTH
        },
        backgroundColor: '#1d212d',
        scene: [BootScene, PreloadScene, MainScene]
      };
      new Phaser.Game(config);
    });
  </script>
</body>
</html>
