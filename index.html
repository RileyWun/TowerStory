<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TowerStory</title>
  <style>
    html, body { height:100%; width:100%; margin:0; padding:0; background: url('assets/images/background.png') center/cover no-repeat; }
    body { display:grid; grid-template-rows:80px auto 60px; grid-template-columns:200px auto 200px;
      grid-template-areas:"header header header" "sidebar-left main sidebar-right" "footer footer footer";
      align-items:center; justify-items:center; }
    #header{grid-area:header;} #sidebar-left{grid-area:sidebar-left;} #sidebar-right{grid-area:sidebar-right;} #footer{grid-area:footer;}
    #game-container{grid-area:main; display:flex; align-items:center; justify-content:center; width:100%; height:100%; overflow:hidden;}
    #game-container canvas{max-width:100%; max-height:100%;}
  </style>
</head>
<body>
  <div id="header"></div>
  <div id="sidebar-left"></div>
  <div id="game-container"></div>
  <div id="sidebar-right"></div>
  <div id="footer"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    window.addEventListener('load', () => {
      class BootScene extends Phaser.Scene { constructor(){super('Boot');} create(){this.scene.start('Preload');} }
      class PreloadScene extends Phaser.Scene {
        constructor(){super('Preload');}
        preload(){
          this.load.tilemapTiledJSON('room','assets/maps/room.json');
          this.load.spritesheet('tileset','assets/tiles/tileset.png',{frameWidth:38,frameHeight:38});
          this.load.spritesheet('player','assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png',{frameWidth:32,frameHeight:32});
          this.load.image('chest','assets/objects/chest.png');
          this.load.image('npc','assets/objects/npc.png');
          this.load.image('potion','assets/icons/potion.png');
          this.load.image('sword','assets/icons/sword.png');
          this.load.image('coin','assets/icons/coin.png');
        }
        create(){this.scene.start('Main');}
      }
      class MainScene extends Phaser.Scene {
        constructor() { super('Main'); }
        create() {
          // Map and rendering
          const map = this.make.tilemap({ key: 'room' });
          this.tileW = map.tileWidth;
          this.tileH = map.tileHeight;
          this.mapW  = map.width;
          this.mapH  = map.height;
          map.addTilesetImage('tileset','tileset',this.tileW,this.tileH);
          this.offsetX = this.scale.width/2;
          this.offsetY = (this.scale.height - (this.mapW+this.mapH)*this.tileH/2)/2 + this.tileH/2;
          this.floorData = map.getLayer('Floor').data.map(r=>r.map(t=>!!t&&t.index>0));
          this.collisionData = map.getLayer('Collision').data.map(r=>r.map(t=>!!t&&t.index>0));
          this.floorGroup = this.add.group();
          map.getLayer('Floor').data.forEach((row,y)=>{
            row.forEach((t,x)=>{
              if(t.index>0){
                const frame = t.index-1;
                const sx = (x-y)*this.tileW/2+this.offsetX;
                const sy = (x+y)*this.tileH/2+this.offsetY;
                this.floorGroup.add(this.add.sprite(sx,sy,'tileset',frame).setDepth(sy));
              }
            });
          });

          // Spawn interactive objects
          const objectLayer = map.getObjectLayer('Objects');
          const spawnObj = map.findObject('Objects',o=>o.name==='PlayerSpawn');
          objectLayer.objects.push({ name:'Chest1', type:'Chest', x:spawnObj.x+this.tileW*2, y:spawnObj.y, visible:true });
          objectLayer.objects.push({ name:'NPC1',   type:'NPC',   x:spawnObj.x-this.tileW*2, y:spawnObj.y, visible:true });

          this.chests = [];
          objectLayer.objects.forEach(o=>{
            const ix=o.x/this.tileW, iy=o.y/this.tileH;
            const sx=(ix-iy)*this.tileW/2+this.offsetX;
            const sy=(ix+iy)*this.tileH/2+this.offsetY;
            if(o.type==='Chest'){
              const chest = this.add.image(sx,sy,'chest').setOrigin(0.5,1).setDepth(sy).setInteractive();
              chest.inventory = [{iconKey:'coin'}, {iconKey:'potion'}];
              chest.on('pointerdown',()=>{
                this.scene.pause();
                this.scene.launch('InventoryScene',{ playerInv:this.player.inventory, chestInv:chest.inventory });
              });
              this.chests.push(chest);
            }
            if(o.type==='NPC'){
              this.add.image(sx,sy,'npc').setOrigin(0.5,1).setDepth(sy);
            }
          });

          // Player
          this.playerInv = [{iconKey:'potion'},{iconKey:'sword'}];
          this.player = this.add.sprite(0,0,'player').setOrigin(0.5,1);
          this.player.inventory = this.playerInv;
          this.createPlayerAnims();
          this.playerIsoX = spawnObj.x/this.tileW;
          this.playerIsoY = spawnObj.y/this.tileH;
          this.updatePlayerPosition();
          this.keys = this.input.keyboard.addKeys('W,A,S,D');
          this.cameras.main.setBounds(0,0,map.widthInPixels,map.heightInPixels);
          this.cameras.main.startFollow(this.player,true,0.1,0.1);

          // Listen for inventory close
          this.events.on('inventoryClosed', data=>{
            this.player.inventory = data.playerInv;
            this.chests[0].inventory = data.chestInv;
            this.scene.resume();
          });
        }
        update(time,delta){
          const dt=delta/1000,spd=3;let moved=false;
          let dir=this.lastDir||'down'; let nx=this.playerIsoX,ny=this.playerIsoY;
          const {W,A,S,D}=this.keys;
          if(W.isDown){ny-=spd*dt;dir='up';moved=true;this.player.play('walk-up',true);} else if(S.isDown){ny+=spd*dt;dir='down';moved=true;this.player.play('walk-down',true);}
          if(A.isDown){nx-=spd*dt;dir='left';moved=true;this.player.play('walk-left',true);} else if(D.isDown){nx+=spd*dt;dir='right';moved=true;this.player.play('walk-right',true);}
          if(nx>=0&&nx<this.mapW&&ny>=0&&ny<this.mapH){const tx=Math.floor(nx),ty=Math.floor(ny);
            if(this.floorData[ty][tx]&&!this.collisionData[ty][tx]){this.playerIsoX=nx;this.playerIsoY=ny;}}
          if(!moved){this.player.anims.stop();this.player.setFrame({down:0,left:12,right:24,up:36}[dir]);}
          this.lastDir=dir;this.updatePlayerPosition();
        }
        createPlayerAnims(){[['down',0,3],['left',12,15],['right',24,27],['up',36,39],['down-left',48,51],['down-right',60,63],['up-left',72,75],['up-right',84,87]].forEach(([k,s,e])=>{
          this.anims.create({key:`walk-${k}`,frames:this.anims.generateFrameNumbers('player',{start:s,end:e}),frameRate:8,repeat:-1});
        });}
        updatePlayerPosition(){const x=this.playerIsoX,y=this.playerIsoY;
          const sx=(x-y)*this.tileW/2+this.offsetX,sy=(x+y)*this.tileH/2+this.offsetY;
          this.player.setPosition(sx,sy).setDepth(sy);
        }
      }

      // Inventory UI with frame, title, drag-and-drop, stacking, slot limits
      class InventoryScene extends Phaser.Scene {
        constructor() { super('InventoryScene'); }
        init(data) {
          this.playerInv = data.playerInv;
          this.chestInv  = data.chestInv;
        }
        create() {
          const width = this.scale.width;
          const height = this.scale.height;
          // Panel dimensions
          this.panelWidth = 200;
          this.panelHeight= 300;
          // Define panels
          this.leftPanel  = new Phaser.Geom.Rectangle(50, 50, this.panelWidth, this.panelHeight);
          this.rightPanel = new Phaser.Geom.Rectangle(width - 50 - this.panelWidth, 50, this.panelWidth, this.panelHeight);
          // Make title-bar zones for dragging panels
          this.leftZone  = this.add.zone(this.leftPanel.x, this.leftPanel.y, this.panelWidth, 20).setOrigin(0).setInteractive();
          this.rightZone = this.add.zone(this.rightPanel.x, this.rightPanel.y, this.panelWidth, 20).setOrigin(0).setInteractive();
          this.input.setDraggable(this.leftZone);
          this.input.setDraggable(this.rightZone);
          // Group for UI drawing
          this.uiGroup = this.add.group();
          // Input events for dragging panels and items
          this.input.on('dragstart', (pointer, gameObj) => {
            if (gameObj === this.leftZone || gameObj === this.rightZone) {
              gameObj.setData('startX', gameObj.x);
              gameObj.setData('startY', gameObj.y);
            } else {
              gameObj.setDepth(1000);
            }
          });
          this.input.on('drag', (pointer, gameObj, dragX, dragY) => {
            if (gameObj === this.leftZone) {
              this.leftPanel.x = dragX;
              this.leftPanel.y = dragY;
              this.leftZone.x = dragX;
              this.leftZone.y = dragY;
            } else if (gameObj === this.rightZone) {
              this.rightPanel.x = dragX;
              this.rightPanel.y = dragY;
              this.rightZone.x = dragX;
              this.rightZone.y = dragY;
            } else {
              gameObj.x = dragX;
              gameObj.y = dragY;
            }
            this.redraw();
          });
          this.input.on('dragend', this.onDragEnd, this);
          // Draw initial UI
          this.redraw();
          // Close on ESC
          this.input.keyboard.on('keydown-ESC', () => this.close());
        }
        redraw() {
          // Clear previous UI
          this.uiGroup.clear(true, true);
          // Draw background panels
          const g = this.add.graphics();
          g.fillStyle(0x222222, 0.8);
          g.fillRectShape(this.leftPanel);
          g.fillRectShape(this.rightPanel);
          this.uiGroup.add(g);
          // Titles
          const t1 = this.add.text(this.leftPanel.x + 10, this.leftPanel.y + 10, 'Inventory', { fontSize:'16px', fill:'#fff' });
          const t2 = this.add.text(this.rightPanel.x+10, this.rightPanel.y+10, 'Chest', { fontSize:'16px', fill:'#fff' });
          this.uiGroup.addMultiple([t1, t2]);
          // Draw slots and items
          this.drawSlots(this.leftPanel, this.playerInv, 'player');
          this.drawSlots(this.rightPanel, this.chestInv,  'chest');
        }
        drawSlots(panel, arr, source) {
          const maxCols = 4, maxRows = 5;
          arr.forEach((item, i) => {
            const count = item.count || 1;
            const col = i % maxCols;
            const row = Math.floor(i / maxCols);
            if (row >= maxRows) return;
            const x = panel.x + 10 + col * 48;
            const y = panel.y + 40 + row * 48;
            // Slot background
            const slotBg = this.add.rectangle(x, y, 44, 44, 0x444444).setOrigin(0);
            this.uiGroup.add(slotBg);
            // Icon
            const icon = this.add.image(x+22, y+22, item.iconKey)
                              .setInteractive({ draggable: true })
                              .setData('source', source)
                              .setData('index', i);
            this.uiGroup.add(icon);
            // Count text
            if (count > 1) {
              const cntText = this.add.text(x+32, y+32, count.toString(), { fontSize:'12px', fill:'#fff' }).setOrigin(1);
              this.uiGroup.add(cntText);
            }
          });
        }
        onDragEnd(pointer, icon) {
          // Panel drag handled earlier
          if (!icon.getData) return;
          const x = pointer.x;
          const y = pointer.y;
          const from = icon.getData('source');
          const idx  = icon.getData('index');
          const srcArr = from === 'player' ? this.playerInv : this.chestInv;
          const destArr= from === 'player' ? this.chestInv  : this.playerInv;
          const destPanel = from === 'player' ? this.rightPanel : this.leftPanel;
          if (destPanel.contains(x, y)) {
            const item = srcArr[idx];
            const existing = destArr.find(it => it.iconKey === item.iconKey);
            if (existing) {
              existing.count = (existing.count || 1) + (item.count || 1);
            } else if (destArr.length < 20) {
              destArr.push({ iconKey: item.iconKey, count: item.count || 1 });
            }
            srcArr.splice(idx, 1);
          }
          this.redraw();
        }
        close() {
          this.scene.get('Main').events.emit('inventoryClosed', { playerInv: this.playerInv, chestInv: this.chestInv });
          this.scene.stop();
        }
      }

      const config = { type: Phaser.AUTO, parent:'game-container', scale:{ mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }, physics:{ default:'arcade' }, scene:[BootScene,PreloadScene,MainScene,InventoryScene] };
      new Phaser.Game(config);
    });={ type: Phaser.AUTO, parent:'game-container', scale:{mode:Phaser.Scale.FIT,autoCenter:Phaser.Scale.CENTER_BOTH}, physics:{default:'arcade'}, scene:[BootScene,PreloadScene,MainScene,InventoryScene] };
      new Phaser.Game(config);
    });
  </script>
</body>
</html>={ type:Phaser.AUTO, parent:'game-container', scale:{mode:Phaser.Scale.FIT,autoCenter:Phaser.Scale.CENTER_BOTH}, physics:{default:'arcade'}, scene:[BootScene,PreloadScene,MainScene,InventoryScene] };
      new Phaser.Game(config);
    });
  </script>
</body>
</html>
