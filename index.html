<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TowerStory</title>
  <style>
    html, body { height:100%; width:100%; margin:0; padding:0; background: url('assets/images/background.png') center/cover no-repeat; }
    body { display:grid; grid-template-rows:80px auto 60px; grid-template-columns:200px auto 200px;
      grid-template-areas:"header header header" "sidebar-left main sidebar-right" "footer footer footer";
      align-items:center; justify-items:center; }
    #header{grid-area:header;} #sidebar-left{grid-area:sidebar-left;} #sidebar-right{grid-area:sidebar-right;} #footer{grid-area:footer;}
    #game-container{grid-area:main; display:flex; align-items:center; justify-content:center; width:100%; height:100%; overflow:hidden;}
    #game-container canvas{max-width:100%; max-height:100%;}
  </style>
</head>
<body>
  <div id="header"></div>
  <div id="sidebar-left"></div>
  <div id="game-container"></div>
  <div id="sidebar-right"></div>
  <div id="footer"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    window.addEventListener('load', () => {
      class BootScene extends Phaser.Scene {
        constructor() { super('Boot'); }
        preload() {}
        create() { this.scene.start('Preload'); }
      }

      class PreloadScene extends Phaser.Scene {
        constructor() { super('Preload'); }
        preload() {
          // Load Tiled map JSON and tileset image
          // Load Tiled map JSON
          this.load.tilemapTiledJSON('room', 'assets/maps/room.json');
          // Load tileset as spritesheet for manual isometric rendering
          this.load.spritesheet('tileset', 'assets/tiles/tileset.png', { frameWidth: 38, frameHeight: 38 });
          // Load player spritesheet
          this.load.spritesheet('player', 'assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png', { frameWidth: 32, frameHeight: 32 });
        }
        create() { this.scene.start('Main'); }
      }

      class MainScene extends Phaser.Scene {
        constructor() { super('Main'); }
        create() {
          // Create map and layers
          const map = this.make.tilemap({ key: 'room' });
          const tileW = map.tileWidth;
          const tileH = map.tileHeight;
          const tileset = map.addTilesetImage('tileset', 'tileset', tileW, tileH, 0, 0);

          // Manual isometric floor rendering
          const mapW = map.width;
          const mapH = map.height;
          // Center offsets
          this.offsetX = this.scale.width / 2;
          this.offsetY = (this.scale.height - (mapW + mapH) * (tileH / 2)) / 2 + (tileH / 2);
          // Draw floor tiles
          for (let y = 0; y < mapH; y++) {
            for (let x = 0; x < mapW; x++) {
              const tile = map.getTileAt(x, y, false, 'Floor');
              if (!tile) continue;
              const gid = tile.index;
              if (gid <= 0) continue;
              const local = gid - 1;
              const sx = (x - y) * (tileW / 2) + this.offsetX;
              const sy = (x + y) * (tileH / 2) + this.offsetY;
              this.add.sprite(sx, sy, 'tileset', local).setDepth(sy);
            }
          }

          // Collision data from layer
          this.collisionData = [];
          const collisionLayer = map.getLayer('Collision').data;
          for (let y = 0; y < mapH; y++) {
            this.collisionData[y] = [];
            for (let x = 0; x < mapW; x++) {
              const tile = collisionLayer[y][x];
              this.collisionData[y][x] = tile && tile.index > 0;
            }
          }
 (invisible)
          const collisionLayer = map.createLayer('Collision', [tileset], 0, 0);
          collisionLayer.setVisible(false);
          collisionLayer.setCollisionByExclusion([-1]);

          // Spawn player at object position
          const spawnPoint = map.findObject('Objects', obj => obj.name === 'PlayerSpawn');
          // Use manual iso coords centered on spawn
          this.playerIsoX = spawnPoint.x / tileW;
          this.playerIsoY = spawnPoint.y / tileH;
          this.player = this.add.sprite(0, 0, 'player').setOrigin(0.5, 1);
          // Initial placement
          const initX = (this.playerIsoX - this.playerIsoY) * (tileW / 2) + this.offsetX;
          const initY = (this.playerIsoX + this.playerIsoY) * (tileH / 2) + this.offsetY;
          this.player.setPosition(initX, initY).setDepth(initY);

          // Player animations (8 directions) (8 directions)
          [['down',0,3],['left',12,15],['right',24,27],['up',36,39],
           ['down-left',48,51],['down-right',60,63],['up-left',72,75],['up-right',84,87]
          ].forEach(([key,start,end]) => {
            this.anims.create({ key: `walk-${key}`, frames: this.anims.generateFrameNumbers('player', { start, end }), frameRate: 8, repeat: -1 });
          });

          // Physics collision
          this.physics.add.collider(this.player, collisionLayer);

          // Input keys
          this.keys = this.input.keyboard.addKeys('W,A,S,D');

          // Camera setup
          const cam = this.cameras.main;
          cam.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
          cam.startFollow(this.player, true, 0.1, 0.1);
          cam.setZoom(1);
        }

        update(time, delta) {
          const speed = 100;
          let moving = false;
          let dir = this.lastDir || 'down';
          const dt = delta / 1000;
          const { W, A, S, D } = this.keys;

          if (W.isDown) { this.player.y -= speed * dt; this.player.play('walk-up', true); dir = 'up'; moving = true; }
          if (S.isDown) { this.player.y += speed * dt; this.player.play('walk-down', true); dir = 'down'; moving = true; }
          if (A.isDown) { this.player.x -= speed * dt; this.player.play('walk-left', true); dir = 'left'; moving = true; }
          if (D.isDown) { this.player.x += speed * dt; this.player.play('walk-right', true); dir = 'right'; moving = true; }

          if (!moving) {
            this.player.anims.stop();
            const idleFrame = { down: 0, left: 12, right: 24, up: 36 }[dir];
            this.player.setFrame(idleFrame);
          }

          this.player.setDepth(this.player.y);
          this.lastDir = dir;
        }
      }

      const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
        physics: { default: 'arcade', arcade: { debug: false } },
        scene: [BootScene, PreloadScene, MainScene]
      };
      new Phaser.Game(config);
    });
  </script>
</body>
</html>
