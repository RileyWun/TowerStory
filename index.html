<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TowerStory</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; }
    #game-container { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <!-- Phaser 3 -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <!-- Phaser Isometric Plugin (v0.0.7) -->
  <script src="https://cdn.jsdelivr.net/npm/phaser3-plugin-isometric@0.0.7/dist/phaser3-plugin-isometric.min.js"></script>

  <script>
    window.addEventListener('load', () => {
      console.log('Iso Plugin object:', window.IsoPlugin);

      const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        width: 800,
        height: 600,
        backgroundColor: '#1d212d',
        scene: [BootScene, PreloadScene, MainScene],
        plugins: {
          scene: [
            {
              key: 'iso',
              plugin: window.IsoPlugin,
              mapping: 'iso'
            }
          ]
        }
      };

      const game = new Phaser.Game(config);

      class BootScene extends Phaser.Scene {
        constructor() { super('Boot'); }
        preload() {}
        create() { this.scene.start('Preload'); }
      }

      class PreloadScene extends Phaser.Scene {
        constructor() { super('Preload'); }
        preload() {
          this.load.image('tile', 'assets/tiles/tile.png');
          this.load.image('player', 'assets/player/player.png');
        }
        create() { this.scene.start('Main'); }
      }

      class MainScene extends Phaser.Scene {
        constructor() { super('Main'); }
        create() {
          // Generate isometric grid
          this.isoGroup = this.add.group();
          const tileSize = 38;
          const mapW = 20, mapH = 20;
          for (let x = 0; x < mapW; x++) {
            for (let y = 0; y < mapH; y++) {
              const isoX = x * tileSize;
              const isoY = y * tileSize;
              const tile = this.iso.add.isoSprite(isoX, isoY, 0, 'tile');
              tile.setDepth(tile.y);
              this.isoGroup.add(tile);
            }
          }

          // Player
          const startX = (mapW/2) * tileSize;
          const startY = (mapH/2) * tileSize;
          this.player = this.iso.add.isoSprite(startX, startY, 0, 'player');
          this.player.setOrigin(0.5, 0.9);
          this.player.setDepth(this.player.y);

          // Input
          this.keys = this.input.keyboard.addKeys({
            W: 'W', A: 'A', S: 'S', D: 'D'
          });
          this.cursors = this.input.keyboard.createCursorKeys();

          // Camera
          const cam = this.cameras.main;
          cam.setBounds(0, 0, mapW*tileSize, mapH*tileSize);
          cam.startFollow(this.player, true, 0.1, 0.1);

          // Drag
          this.input.on('pointerdown', () => this.dragging=true);
          this.input.on('pointerup', () => this.dragging=false);
          this.input.on('pointermove', (p) => {
            if (this.dragging) {
              cam.scrollX -= (p.x - p.prevPosition.x)/cam.zoom;
              cam.scrollY -= (p.y - p.prevPosition.y)/cam.zoom;
            }
          });
        }

        update(t, dt) {
          const delta = dt/1000;
          // Move player
          const speed = 100;
          if (this.keys.A.isDown) this.player.isoX -= speed*delta;
          if (this.keys.D.isDown) this.player.isoX += speed*delta;
          if (this.keys.W.isDown) this.player.isoY -= speed*delta;
          if (this.keys.S.isDown) this.player.isoY += speed*delta;

          // Depth sort
          this.isoGroup.getChildren().sort((a,b)=>a.y-b.y);
          this.player.setDepth(this.player.y);
        }
      }
    });
  </script>
</body>
</html>
