<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TowerStory</title>
  <style>
    html, body { 
      height:100%; 
      width:100%; 
      margin:0; 
      padding:0; 
      background: url('assets/images/background.png') center/cover no-repeat; 
    }
    body {
      display: grid;
      grid-template-rows: 80px auto 60px;
      grid-template-columns: 200px auto 200px;
      grid-template-areas:
        "header header header"
        "sidebar-left main sidebar-right"
        "footer footer footer";
    }
    #header           { grid-area: header; }
    #sidebar-left     { grid-area: sidebar-left; }
    #game-container   { 
      grid-area: main; 
      position: relative; 
      width: 100%; 
      height: 100%; 
      overflow: hidden; 
    }
    #sidebar-right    { grid-area: sidebar-right; }
    #footer           { grid-area: footer; }
    #game-container canvas { display: block; margin: auto; }
  </style>
</head>
<body>
  <div id="header"></div>
  <div id="sidebar-left"></div>
  <div id="game-container"></div>
  <div id="sidebar-right"></div>
  <div id="footer"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script type="module">
    import { NPCManager }           from './assets/js/npc-manager.js';
    import { QuestManager }         from './assets/js/quest-manager.js';
    import { DialogueTreeManager }  from './assets/js/dialogue-tree-manager.js';
    import { TradeManager }         from './assets/js/trade-manager.js';
    import { TradeScene }           from './assets/js/trade-scene.js';
    import { InventoryScene }       from './assets/js/inventory-scene.js';
    import { QuantityScene }        from './assets/js/quantity-scene.js';
    import { Enemy }                from './assets/js/enemy.js';

    window.addEventListener('load', () => {
      // ────────────────────────────────────────────────────────────────
      // BootScene: immediately start Preload
      class BootScene extends Phaser.Scene {
        constructor(){ super('Boot'); }
        create(){ this.scene.start('Preload'); }
      }

      // PreloadScene: load all assets
      class PreloadScene extends Phaser.Scene {
        constructor(){ super('Preload'); }
        preload(){
          this.load.tilemapTiledJSON('room', 'assets/maps/room.json');
          this.load.spritesheet('tileset', 'assets/tiles/tileset.png',   { frameWidth:38, frameHeight:38 });
          this.load.spritesheet('player','assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png', { frameWidth:32, frameHeight:32 });
          this.load.image('chest',   'assets/objects/chest.png');
          this.load.image('npc',     'assets/objects/npc.png');
          this.load.image('potion',  'assets/icons/potion.png');
          this.load.image('sword',   'assets/icons/sword.png');
          this.load.image('coin',    'assets/icons/coin.png');
          this.load.image('slime',   'assets/objects/slime.png');
          // You may also load separate loot textures if you like:
          // this.load.image('loot-coin','assets/icons/coin.png');
          // this.load.image('loot-potion','assets/icons/potion.png');
        }
        create(){ this.scene.start('Main'); }
      }

      // ────────────────────────────────────────────────────────────────
      // MainScene: draw the map, place objects, set up managers, etc.
      class MainScene extends Phaser.Scene {
        constructor(){ super('Main'); }

        create(){
          // 1) Create the tilemap and compute offsets for isometric rendering
          const map = this.make.tilemap({ key: 'room' });
          map.addTilesetImage('tileset', 'tileset', map.tileWidth, map.tileHeight);
          this.tileW = map.tileWidth;
          this.tileH = map.tileHeight;
          this.mapW  = map.width;
          this.mapH  = map.height;

          // center the entire map in the viewport
          this.offsetX = this.scale.width  / 2;
          this.offsetY = (this.scale.height - (this.mapW + this.mapH)*(this.tileH/2)) / 2 + this.tileH/2;

          // 2) Draw the floor layer
          this.floorData = map.getLayer('Floor').data.map(row => row.map(tile => tile.index > 0));
          this.collisionData = map.getLayer('Collision').data.map(row => row.map(tile => tile.index > 0));
          map.getLayer('Floor').data.forEach((row, y) => {
            row.forEach((tile, x) => {
              if (tile.index > 0) {
                const frame = tile.index - 1;
                const sx = (x - y)*(this.tileW/2) + this.offsetX;
                const sy = (x + y)*(this.tileH/2) + this.offsetY;
                this.add.image(sx, sy, 'tileset', frame).setDepth(sy);
              }
            });
          });

          // 3) Read all Tiled objects (PlayerSpawn, Chest, NPC, MobSpawn, etc.)
          const objs       = map.getObjectLayer('Objects').objects;
          const spawnPoint = objs.find(o => o.name === 'PlayerSpawn');

          // 4) Prepare player inventory and chest list
          this.playerInv = [
            { iconKey: 'potion', count: 3 },
            { iconKey: 'sword',  count: 1 }
          ];
          this.chests   = [];

          // 5) Create empty groups for enemies and loot
          this.enemies   = this.add.group();
          this.lootGroup = this.physics.add.group();

          // 6) Loop through every object in Tiled
          objs.forEach(o => {
            // convert Tiled (o.x, o.y) to isometric tile coords
            const ix = o.x / this.tileW;
            const iy = o.y / this.tileH;
            const sx = (ix - iy)*(this.tileW/2) + this.offsetX;
            const sy = (ix + iy)*(this.tileH/2) + this.offsetY;

            // ─── (A) CHESTS ───────────────────────────────────────────
            if (o.type === 'Chest') {
              const chest = this.add.image(sx, sy, 'chest')
                                  .setOrigin(0.5, 1)
                                  .setDepth(sy)
                                  .setInteractive();
              chest.inventory = [];
              chest.on('pointerdown', () => {
                this.openInventory(this.playerInv, chest.inventory);
              });
              this.chests.push(chest);
            }

            // ─── (B) NPCs ─────────────────────────────────────────────
            else if (o.type === 'NPC') {
              // NPCs will be handled later by NPCManager
            }

            // ─── (C) MOB SPAWN (IMMEDIATE ONCE) ───────────────────────
            else if (o.type === 'MobSpawn') {
              const areaLeft   = o.x;
              const areaTop    = o.y;
              const areaWidth  = o.width  || this.tileW;
              const areaHeight = o.height || this.tileH;

              const props      = (o.properties || []).reduce((acc, p) => {
                acc[p.name] = p.value;
                return acc;
              }, {});
              const mobType   = props.mobType   || 'slime';
              const spawnRate = props.spawnRate || 0.0;

              if (spawnRate === 0) {
                // drop exactly one mob at a random point within that rectangle
                const randX = Phaser.Math.FloatBetween(areaLeft, areaLeft + areaWidth);
                const randY = Phaser.Math.FloatBetween(areaTop,  areaTop  + areaHeight);

                const isoX = randX / this.tileW;
                const isoY = randY / this.tileH;
                const randomLevel = Phaser.Math.Between(1, 5);
                const mob = new Enemy(this, isoX, isoY, mobType, randomLevel);
                this.enemies.add(mob);
              }
            }
          });

          // 7) Now that all Tiled objects are handled, create the player:
                this.player = this.physics.add.sprite(0, 0, 'player')
                    .setOrigin(0.5, 1);
                this.playerIsoX = spawnPoint.x / this.tileW;
                this.playerIsoY = spawnPoint.y / this.tileH;
                const px = (this.playerIsoX - this.playerIsoY)*(this.tileW/2) + this.offsetX;
                const py = (this.playerIsoX + this.playerIsoY)*(this.tileH/2) + this.offsetY;
                this.player.setPosition(px, py).setDepth(py);

          // 8) Set up keyboard movement and camera
          this.keys = this.input.keyboard.addKeys('W,A,S,D');

          // ─── REGISTER SPACE FOR MELEE ATTACK ──────────────────────────
          this.keys.SPACE = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
          this.keys.SPACE.on('down', () => {
            this.playerAttack();
          });

          this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
          this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

          // ─── When player overlaps/“touches” any loot icon, pick it up ───
          this.physics.add.overlap(
            this.player,
            this.lootGroup,
            (playerSprite, lootSprite) => {
              if (lootSprite.collected) return; // already picked up
              lootSprite.collected = true;

              // 1) Add to player inventory: either stack or push new
              const inv = this.playerInv;
              const existing = inv.find(i => i.iconKey === lootSprite.itemKey);
              if (existing) {
                existing.count += lootSprite.quantity;
              } else {
                inv.push({ iconKey: lootSprite.itemKey, count: lootSprite.quantity });
              }

              // 2) “Pop” the icon visually, then destroy
              this.tweens.add({
                targets: lootSprite,
                scaleX: 1.5,
                scaleY: 1.5,
                alpha: 0,
                duration: 200,
                onComplete: () => lootSprite.destroy()
              });

              // 3) If inventory is open, refresh immediately
              if (this.scene.isActive('InventoryScene')) {
                this.events.emit('refreshInventory', this.playerInv);
              }
            }
          );

          // ─── (9) MANAGERS ──────────────────────────────────────────
          this.npcManager   = new NPCManager(this);
          this.npcManager.createFromObjects(objs);

          this.questManager = new QuestManager(this);
          this.dialogueTree = new DialogueTreeManager(this);
          this.tradeManager = new TradeManager(this);

          // (9a) Load each quest dialog tree first
          this.questManager.quests.forEach(quest => {
            if (!quest.dialogueFile) return;
            import(`./assets/js/dialogues/${quest.dialogueFile}`)
              .then(mod => {
                console.log(`Registered quest tree for ${quest.id}`);
                this.dialogueTree.registerTree(quest.id, mod.default);
              })
              .catch(err => console.warn(`Failed to load quest tree for ${quest.id}`, err));
          });

          // (9b) Load each NPC’s “main” dialogue tree
          this.npcManager.npcs.forEach(npc => {
            import(`./assets/js/dialogues/${npc.npcId}-tree.js`)
              .then(mod => {
                console.log(`Registered main tree for ${npc.npcId}`);
                this.dialogueTree.registerTree(npc.npcId, mod.default);
              })
              .catch(err => console.warn(`No dialogue module for ${npc.npcId}`, err));
          });

          // 10) Enable “F” to talk to NPC when close
          this.npcManager.enableConversations('F', npc =>
            this.dialogueTree.startDialogue(npc.npcId)
          );

          // 11) Inventory & Chest hotkeys
          this.events.on('inventoryClosed', data => {
            this.playerInv = data.playerInv;
            this.scene.resume();
          });
          this.input.keyboard.on('keydown-I', () => this.openInventory(this.playerInv, null));
          this.input.keyboard.on('keydown-E', () => {
            const { x, y } = this.player;
            this.chests.forEach(ch => {
              if (Phaser.Math.Distance.Between(x, y, ch.x, ch.y) < 50) {
                this.openInventory(this.playerInv, ch.inventory);
              }
            });
          });
        } // ← End of MainScene.create()

        createPlayerAnims(){
          [
            ['down',       0,  3],
            ['left',      12, 15],
            ['right',     24, 27],
            ['up',        36, 39],
            ['down-left', 48, 51],
            ['down-right',60, 63],
            ['up-left',   72, 75],
            ['up-right',  84, 87]
          ].forEach(([k, s, e]) => {
            this.anims.create({
              key: `walk-${k}`,
              frames: this.anims.generateFrameNumbers('player', { start: s, end: e }),
              frameRate: 8,
              repeat: -1
            });
          });
        }

        openInventory(playerInv, chestInv){
          this.scene.pause();
          this.scene.launch('InventoryScene', { playerInv, chestInv });
        }
        closeInventory(){
          this.scene.stop('InventoryScene');
          this.scene.resume();
        }

        openChoice(question, options, callback){
          this.scene.pause();
          this.scene.launch('ChoiceScene', { question, options, callback });
        }

        update(time, delta){
          const dt = delta / 1000, spd = 3;
          let moved = false, dir = this.lastDir || 'down';
          let nx = this.playerIsoX, ny = this.playerIsoY;
          const { W, A, S, D } = this.keys;

          if (W.isDown) {
            ny -= spd * dt; dir = 'up';    moved = true; this.player.play('walk-up', true);
          }
          else if (S.isDown) {
            ny += spd * dt; dir = 'down';  moved = true; this.player.play('walk-down', true);
          }
          if (A.isDown) {
            nx -= spd * dt; dir = 'left';  moved = true; this.player.play('walk-left', true);
          }
          else if (D.isDown) {
            nx += spd * dt; dir = 'right'; moved = true; this.player.play('walk-right', true);
          }

          const tx = Math.floor(nx), ty = Math.floor(ny);
          if (
            nx >= 0 && nx < this.mapW &&
            ny >= 0 && ny < this.mapH &&
            this.floorData[ty][tx] && !this.collisionData[ty][tx]
          ) {
            this.playerIsoX = nx;
            this.playerIsoY = ny;
          }

          if (!moved) {
            this.player.anims.stop();
            this.player.setFrame({ down:0, left:12, right:24, up:36 }[dir]);
          }
          this.lastDir = dir;

          const sx = (this.playerIsoX - this.playerIsoY)*(this.tileW/2) + this.offsetX;
          const sy = (this.playerIsoX + this.playerIsoY)*(this.tileH/2) + this.offsetY;
          this.player.setPosition(sx, sy).setDepth(sy);

          // ─── Update all enemies every frame ────────────────────────
          this.enemies.getChildren().forEach(enemy => {
            if (enemy && enemy.preUpdate) {
              enemy.preUpdate(time, delta);
            }
          });
        } // ← End of update()

        // ─── PLAYER MELEE ATTACK (SPACE) ──────────────────────────────
        playerAttack() {
          const px = this.player.x;
          const py = this.player.y;

          this.enemies.getChildren().forEach(enemy => {
            if (!enemy || !enemy.active) return;
            const dist = Phaser.Math.Distance.Between(px, py, enemy.x, enemy.y);
            if (dist < enemy.hitRadius + 16) {
              enemy.takeDamage(1);
            }
          });
        }

        /**
         * Create one or more loot-icons at (screenX, screenY).
         * @param {number} x      – screen-space X
         * @param {number} y      – screen-space Y
         * @param {string} key    – texture key for the loot (e.g. 'coin' or 'potion')
         * @param {number} amount – how many items to drop
         */
        spawnLoot(x, y, key, amount = 1) {
          for (let i = 0; i < amount; i++) {
            const dx = Phaser.Math.Between(-8, 8);
            const dy = Phaser.Math.Between(-8, 8);

            const loot = this.add
              .image(x + dx, y + dy, key)
              .setOrigin(0.5, 0.5)
              .setDepth(y + dy);

            loot.setInteractive();
            loot.itemKey  = key;
            loot.quantity = 1;
            loot.collected = false;

            // small bounce tween
            this.tweens.add({
              targets: loot,
              y: (y + dy) - 8,
              ease: 'Power1',
              duration: 200,
              yoyo: true
            });

            this.lootGroup = this.physics.add.group();
            const loot = this.lootGroup.create(x + dx, y + dy, key)
  .setOrigin(0.5, 0.5)
  .setDepth(y + dy);

// by default, physics.add.group().create() gives it a body
loot.body.setAllowGravity(false);
loot.setInteractive();
loot.itemKey   = key;
loot.quantity  = 1;
loot.collected = false;

// small bounce between
this.tweens.add({
  targets: loot,
  y: (y + dy) - 8,
  ease: 'Power1',
  duration: 200,
  yoyo: true
});
          }
        }
      } // End of MainScene

      // ────────────────────────────────────────────────────────────────
      // DialogueScene (shows a block of text, closes on ESC or click)
      class DialogueScene extends Phaser.Scene {
        constructor(){ super('DialogueScene'); }
        init(data){ this.lines = data.lines || []; }
        create(){
          const w = this.scale.width, h = this.scale.height;
          this.add.graphics()
              .fillStyle(0x000000, 0.7)
              .fillRect(w/4, h/4, w/2, h/4);
          this.lines.forEach((l, i) => {
            this.add.text(w/4 + 20, h/4 + 20 + i*24, l, { fontSize:'18px', fill:'#fff' });
          });

          const closeDialog = () => {
            this.scene.stop('DialogueScene');
            this.scene.resume('Main');
            this.scene.get('Main').events.emit('dialogueClosed');
          };
          this.input.keyboard.once('keydown-ESC', closeDialog);
          this.input.once('pointerdown', closeDialog);
        }
      }

      // ────────────────────────────────────────────────────────────────
      // ChoiceScene (question + clickable text options)
      class ChoiceScene extends Phaser.Scene {
        constructor(){ super('ChoiceScene'); }
        init(data){
          this.question = data.question;
          this.options  = data.options  || [];
          this.callback = data.callback;
        }
        create(){
          const w = this.scale.width, h = this.scale.height;
          this.add.graphics()
              .fillStyle(0x000000, 0.7)
              .fillRect(w/4, h/4, w/2, h/4);
          this.add.text(w/4 + 20, h/4 + 20, this.question, { fontSize:'18px', fill:'#fff' });

          this.options.forEach((opt, idx) => {
            const txt = this.add.text(w/4 + 40, h/4 + 60 + idx*30, opt, { fontSize:'16px', fill:'#ff0' })
                              .setInteractive();
            txt.on('pointerdown', () => {
              if (this.callback) this.callback(idx);
              this.scene.stop('ChoiceScene');
              this.scene.resume('Main');
            });
          });
        }
      }

      // ────────────────────────────────────────────────────────────────
      // Game configuration and launch
      const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
        physics: { default: 'arcade' },
        scene: [
          BootScene,
          PreloadScene,
          MainScene,
          DialogueScene,
          ChoiceScene,
          TradeScene,
          InventoryScene,
          QuantityScene
        ]
      };

      new Phaser.Game(config);
    });
  </script>
</body>
</html>
