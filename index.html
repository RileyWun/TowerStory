<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TowerStory</title>
  <style>
    html, body { height:100%; width:100%; margin:0; padding:0; background: url('assets/images/background.png') center/cover no-repeat; }
    body {
      display:grid;
      grid-template-rows:80px auto 60px;
      grid-template-columns:200px auto 200px;
      grid-template-areas:
        "header header header"
        "sidebar-left main sidebar-right"
        "footer footer footer";
    }
    #header { grid-area: header; }
    #sidebar-left { grid-area: sidebar-left; }
    #game-container { grid-area: main; position: relative; width: 100%; height: 100%; overflow:hidden; }
    #sidebar-right { grid-area: sidebar-right; }
    #footer { grid-area: footer; }
    #game-container canvas { display: block; margin: auto; }
  </style>
</head>
<body>
  <div id="header"></div>
  <div id="sidebar-left"></div>
  <div id="game-container"></div>
  <div id="sidebar-right"></div>
  <div id="footer"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script type="module">
    import { NPCManager } from './assets/js/npc-manager.js';
    import { QuestManager } from './assets/js/quest-manager.js';
    import { DialogueTreeManager } from './assets/js/dialogue-tree-manager.js';
    import { TradeManager } from './assets/js/trade-manager.js';

    window.addEventListener('load', () => {
      class BootScene extends Phaser.Scene {
        constructor(){ super('Boot'); }
        create(){ this.scene.start('Preload'); }
      }

      class PreloadScene extends Phaser.Scene {
        constructor(){ super('Preload'); }
        preload(){
          this.load.tilemapTiledJSON('room','assets/maps/room.json');
          this.load.spritesheet('tileset','assets/tiles/tileset.png',{ frameWidth:38,frameHeight:38 });
          this.load.spritesheet('player','assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png',{ frameWidth:32,frameHeight:32 });
          this.load.image('chest','assets/objects/chest.png');
          this.load.image('npc','assets/objects/npc.png');
          this.load.image('potion','assets/icons/potion.png');
          this.load.image('sword','assets/icons/sword.png');
          this.load.image('coin','assets/icons/coin.png');
        }
        create(){ this.scene.start('Main'); }
      }

      class MainScene extends Phaser.Scene {
        constructor(){ super('Main'); }
        create(){
          const map = this.make.tilemap({ key:'room' });
          map.addTilesetImage('tileset','tileset',map.tileWidth,map.tileHeight);
          this.tileW=map.tileWidth; this.tileH=map.tileHeight;
          this.mapW=map.width; this.mapH=map.height;
          this.offsetX=this.scale.width/2;
          this.offsetY=(this.scale.height-(this.mapW+this.mapH)*(this.tileH/2))/2+this.tileH/2;

          // Floor
          this.floorData=map.getLayer('Floor').data.map(r=>r.map(t=>t.index>0));
          this.collisionData=map.getLayer('Collision').data.map(r=>r.map(t=>t.index>0));
          map.getLayer('Floor').data.forEach((row,y)=>row.forEach((t,x)=>{
            if(t.index>0){
              const frame=t.index-1;
              const sx=(x-y)*(this.tileW/2)+this.offsetX;
              const sy=(x+y)*(this.tileH/2)+this.offsetY;
              this.add.image(sx,sy,'tileset',frame).setDepth(sy);
            }
          }));

          // Objects & Chests
          const objs=map.getObjectLayer('Objects').objects;
          const spawn=objs.find(o=>o.name==='PlayerSpawn');
          this.playerInv=[{iconKey:'potion',count:3},{iconKey:'sword',count:1}];
          this.chests=[];
          objs.forEach(o=>{
            const ix=o.x/this.tileW, iy=o.y/this.tileH;
            const sx=(ix-iy)*(this.tileW/2)+this.offsetX;
            const sy=(ix+iy)*(this.tileH/2)+this.offsetY;
            if(o.type==='Chest'){
              const chest=this.add.image(sx,sy,'chest').setOrigin(0.5,1).setDepth(sy).setInteractive();
              chest.inventory=[];
              chest.on('pointerdown',()=>this.openInventory(this.playerInv,chest.inventory));
              this.chests.push(chest);
            }
          });

          // Player
          this.player=this.add.sprite(0,0,'player').setOrigin(0.5,1);
          this.createPlayerAnims();
          this.playerIsoX=spawn.x/this.tileW; this.playerIsoY=spawn.y/this.tileH;
          const px=(this.playerIsoX-this.playerIsoY)*(this.tileW/2)+this.offsetX;
          const py=(this.playerIsoX+this.playerIsoY)*(this.tileH/2)+this.offsetY;
          this.player.setPosition(px,py).setDepth(py);

          this.keys=this.input.keyboard.addKeys('W,A,S,D');
          this.cameras.main.setBounds(0,0,map.widthInPixels,map.heightInPixels);
          this.cameras.main.startFollow(this.player,true,0.1,0.1);

          // Managers
          this.npcManager=new NPCManager(this);
          this.npcManager.createFromObjects(objs);
          this.questManager=new QuestManager(this);
          this.dialogueTree=new DialogueTreeManager(this);
          this.tradeManager=new TradeManager(this);

// 1) Load each NPC’s main dialogue tree
this.npcManager.npcs.forEach(npc => {
  import(`./assets/js/dialogues/${npc.npcId}-tree.js`)
    .then(mod => this.dialogueTree.registerTree(npc.npcId, mod.default))
    .catch(err => console.warn(`No dialogue module for ${npc.npcId}`, err));
});

// 2) Load each quest dialogue tree, but only if dialogueFile is present:
this.questManager.quests.forEach(quest => {
  if (!quest.dialogueFile) return;

  import(`./assets/js/dialogues/${quest.dialogueFile}`)
    .then(mod => {
      // register it under the quest’s own ID, e.g. "merchant1Quest"
      this.dialogueTree.registerTree(quest.id, mod.default);
    })
    .catch(err => {
      console.warn(`Failed to load quest tree for ${quest.id}`, err);
    });
});
          // Conversation & interactions
          this.npcManager.enableConversations('F', npc =>
            this.dialogueTree.startDialogue(npc.npcId)
          );

          // Inventory & chest keys
          this.events.on('inventoryClosed', data => {
            this.playerInv=data.playerInv;
            this.scene.resume();
          });
          this.input.keyboard.on('keydown-I', ()=>this.openInventory(this.playerInv,null));
          this.input.keyboard.on('keydown-E', ()=>{
            const {x,y}=this.player;
            this.chests.forEach(ch=>{
              if(Phaser.Math.Distance.Between(x,y,ch.x,ch.y)<50)
                this.openInventory(this.playerInv,ch.inventory);
            });
          });
        }

        createPlayerAnims(){
          [['down',0,3],['left',12,15],['right',24,27],['up',36,39],
           ['down-left',48,51],['down-right',60,63],['up-left',72,75],['up-right',84,87]]
          .forEach(([k,s,e])=>{
            this.anims.create({
              key:`walk-${k}`,
              frames:this.anims.generateFrameNumbers('player',{start:s,end:e}),
              frameRate:8,repeat:-1
            });
          });
        }

        openInventory(playerInv,chestInv){
          this.scene.pause();
          this.scene.launch('InventoryScene',{playerInv,chestInv});
        }
        closeInventory(){ this.scene.stop('InventoryScene'); this.scene.resume(); }

        openChoice(question,options,callback){
          this.scene.pause();
          this.scene.launch('ChoiceScene',{question,options,callback});
        }

        update(time,delta){
          const dt=delta/1000,spd=3;
          let moved=false,dir=this.lastDir||'down';
          let nx=this.playerIsoX,ny=this.playerIsoY;
          const {W,A,S,D}=this.keys;

          if(W.isDown){ ny-=spd*dt; dir='up';   moved=true; this.player.play('walk-up',true); }
          else if(S.isDown){ ny+=spd*dt; dir='down'; moved=true; this.player.play('walk-down',true); }
          if(A.isDown){ nx-=spd*dt; dir='left'; moved=true; this.player.play('walk-left',true); }
          else if(D.isDown){ nx+=spd*dt; dir='right';moved=true; this.player.play('walk-right',true); }

          const tx=Math.floor(nx), ty=Math.floor(ny);
          if(nx>=0 && nx<this.mapW && ny>=0 && ny<this.mapH &&
             this.floorData[ty][tx] && !this.collisionData[ty][tx]) {
            this.playerIsoX=nx; this.playerIsoY=ny;
          }

          if(!moved){
            this.player.anims.stop();
            this.player.setFrame({down:0,left:12,right:24,up:36}[dir]);
          }
          this.lastDir=dir;

          const sx=(this.playerIsoX-this.playerIsoY)*(this.tileW/2)+this.offsetX;
          const sy=(this.playerIsoX+this.playerIsoY)*(this.tileH/2)+this.offsetY;
          this.player.setPosition(sx,sy).setDepth(sy);
        }
      }

      // Dialogue Scene
      class DialogueScene extends Phaser.Scene {
        constructor(){ super('DialogueScene'); }
        init(data){ this.lines=data.lines||[]; }
        create(){
          const w=this.scale.width, h=this.scale.height;
          this.add.graphics().fillStyle(0x000000,0.7)
            .fillRect(w/4,h/4,w/2,h/4);
          this.lines.forEach((l,i)=>
            this.add.text(w/4+20,h/4+20+i*24,l,{fontSize:'18px',fill:'#fff'})
          );

          const closeDialog=()=>{
            this.scene.stop('DialogueScene');
            this.scene.resume('Main');
            this.scene.get('Main').events.emit('dialogueClosed');
          };
          this.input.keyboard.once('keydown-ESC', closeDialog);
          this.input.once('pointerdown', closeDialog);
        }
      }

      // Choice Scene
      class ChoiceScene extends Phaser.Scene {
        constructor(){ super('ChoiceScene'); }
        init(data){
          this.question=data.question;
          this.options=data.options||[];
          this.callback=data.callback;
        }
        create(){
          const w=this.scale.width,h=this.scale.height;
          this.add.graphics().fillStyle(0x000000,0.7)
            .fillRect(w/4,h/4,w/2,h/4);
          this.add.text(w/4+20,h/4+20,this.question,{fontSize:'18px',fill:'#fff'});
          this.options.forEach((opt,idx)=>{
            const txt=this.add.text(w/4+40,h/4+60+idx*30,opt,{fontSize:'16px',fill:'#ff0'})
              .setInteractive();
            txt.on('pointerdown',()=>{
              if(this.callback) this.callback(idx);
              this.scene.stop('ChoiceScene');
              this.scene.resume('Main');
            });
          });
        }
      }
      
// Inventory Scene
class InventoryScene extends Phaser.Scene {
  constructor(){ super('InventoryScene'); }

  init(data){
    this.playerInv = data.playerInv;
    this.chestInv  = data.chestInv || [];
    this.showChest = data.chestInv !== null;
  }

  // stub so redraw() exists
  redraw() {
    // move your slot‐drawing code here when you have it
  }

  // stub so dragend listener has a function
  onDragEnd(pointer, gameObject) {
    // no‐op for now (or put post‐drag cleanup here)
  }

  create(){
    const w = this.scale.width;
    this.pw = 200; this.ph = 300;
    this.leftPanel = new Phaser.Geom.Rectangle(50,50,this.pw,this.ph);
    if (this.showChest) {
      this.rightPanel = new Phaser.Geom.Rectangle(w - 50 - this.pw, 50, this.pw, this.ph);
    }

    this.uiGroup = this.add.group();

    this.leftZone = this.add.zone(this.leftPanel.x, this.leftPanel.y, this.pw, 20)
      .setOrigin(0)
      .setInteractive();
    if (this.showChest) {
      this.rightZone = this.add.zone(this.rightPanel.x, this.rightPanel.y, this.pw, 20)
        .setOrigin(0)
        .setInteractive();
    }

    const draggableZones = [ this.leftZone ];
    if (this.showChest) {
      draggableZones.push(this.rightZone);
    }
    this.input.setDraggable(draggableZones);

    this.input.on('drag', (pointer, gameObject, dx, dy) => {
      if (gameObject === this.leftZone) {
        this.leftPanel.x = dx;
        this.leftZone.x  = dx;
        this.leftPanel.y = dy;
        this.leftZone.y  = dy;
        this.redraw();
      }
      else if (this.showChest && gameObject === this.rightZone) {
        this.rightPanel.x = dx;
        this.rightZone.x  = dx;
        this.rightPanel.y = dy;
        this.rightZone.y  = dy;
        this.redraw();
      }
      else {
        gameObject.x = dx;
        gameObject.y = dy;
      }
    });

    this.input.on('dragend', this.onDragEnd, this);

    this.input.keyboard.on('keydown-ESC', () => this.close());
    this.input.keyboard.on('keydown-I',   () => this.close());

    this.redraw();
  }

  close(){
    this.scene.stop('InventoryScene');
    this.scene.resume('Main');
  }
}

      // Trade Scene (placeholder UI)
  class TradeScene extends Phaser.Scene {
  constructor(){ super('TradeScene'); }
  init(data) {
    this.npcId = data.npcId;
  }
  create(){
    const w = this.scale.width, h = this.scale.height;
    // dark backdrop
    this.add.graphics()
      .fillStyle(0x000000, 0.8)
      .fillRect(w/4, h/4, w/2, h/2);
    // simple trade title
    this.add.text(w/4 + 20, h/4 + 20,
      `Trading with ${this.npcId}`, { fontSize:'18px', fill:'#fff' }
    );
    // close on ESC
    this.input.keyboard.once('keydown-ESC', () => {
      this.scene.stop('TradeScene');
      this.scene.resume('Main');
    });
  }
}

      const config={
        type:Phaser.AUTO,
        parent:'game-container',
        scale:{mode:Phaser.Scale.FIT,autoCenter:Phaser.Scale.CENTER_BOTH},
        physics:{default:'arcade'},
        scene:[BootScene,PreloadScene,MainScene,DialogueScene,ChoiceScene,TradeScene,InventoryScene]
      };
      new Phaser.Game(config);
    });
  </script>
</body>
</html>
