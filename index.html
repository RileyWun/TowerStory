<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TowerStory</title>
  <style>
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      background: url('assets/images/background.png') center/cover no-repeat;
    }
    body {
      display: grid;
      grid-template-rows: 80px auto 60px;
      grid-template-columns: 200px auto 200px;
      grid-template-areas:
        "header header header"
        "sidebar-left main sidebar-right"
        "footer footer footer";
    }
    #header { grid-area: header; }
    #sidebar-left { grid-area: sidebar-left; }
    #game-container { 
      grid-area: main; 
      position: relative; 
      width: 100%; 
      height: 100%; 
      overflow: hidden; 
    }
    #sidebar-right { grid-area: sidebar-right; }
    #footer { grid-area: footer; }
    #game-container canvas {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <div id="header"></div>
  <div id="sidebar-left"></div>
  <div id="game-container"></div>
  <div id="sidebar-right"></div>
  <div id="footer"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script type="module">
    import { NPCManager }           from './assets/js/npc-manager.js';
    import { QuestManager }         from './assets/js/quest-manager.js';
    import { DialogueTreeManager }  from './assets/js/dialogue-tree-manager.js';
    import { TradeManager }         from './assets/js/trade-manager.js';
    import { InventoryScene }       from './assets/js/inventory-scene.js';
    import { EquipmentScene }       from './assets/js/equipment-scene.js';
    import { Enemy }                from './assets/js/enemy.js';

    window.addEventListener('load', () => {
      class BootScene extends Phaser.Scene {
        constructor() { super('Boot'); }
        create() { this.scene.start('Preload'); }
      }

      class PreloadScene extends Phaser.Scene {
        constructor() { super('Preload'); }
        preload() {
          this.load.tilemapTiledJSON('room', 'assets/maps/room.json');
          this.load.spritesheet(
            'tileset', 'assets/tiles/tileset.png',
            { frameWidth: 38, frameHeight: 38 }
          );
          this.load.spritesheet(
            'player', 'assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png',
            { frameWidth: 32, frameHeight: 32 }
          );
          this.load.image('chest',  'assets/objects/chest.png');
          this.load.image('npc',    'assets/objects/npc.png');
          this.load.image('potion', 'assets/icons/potion.png');
          this.load.image('sword',  'assets/icons/sword.png');
          this.load.image('coin',   'assets/icons/coin.png');
          this.load.image('slime',  'assets/objects/slime.png');
        }
        create() { this.scene.start('Main'); }
      }

      class MainScene extends Phaser.Scene {
        constructor() { super('Main'); }
        create() {
          const map = this.make.tilemap({ key: 'room' });
          const tileset = map.addTilesetImage('tileset', 'tileset', map.tileWidth, map.tileHeight);
          this.tileW = map.tileWidth;
          this.tileH = map.tileHeight;
          this.mapW = map.width;
          this.mapH = map.height;
          this.offsetX = this.scale.width / 2;
          this.offsetY = (
            this.scale.height - (this.mapW + this.mapH) * (this.tileH / 2)
          ) / 2 + this.tileH / 2;

          // Floor + Collision data
          this.floorData = map.getLayer('Floor').data.map(row => row.map(cell => cell.index > 0));
          this.collisionData = map.getLayer('Collision').data.map(row => row.map(cell => cell.index > 0));
          map.getLayer('Floor').data.forEach((row, y) => {
            row.forEach((cell, x) => {
              if (cell.index > 0) {
                const frame = cell.index - 1;
                const sx = (x - y) * (this.tileW / 2) + this.offsetX;
                const sy = (x + y) * (this.tileH / 2) + this.offsetY;
                this.add.image(sx, sy, 'tileset', frame).setDepth(sy);
              }
            });
          });

          // Objects & Chests
          const objs = map.getObjectLayer('Objects').objects;
          const spawnObj = objs.find(o => o.name === 'PlayerSpawn');
          this.playerInv = [
            { iconKey: 'potion', count: 3 },
            { iconKey: 'sword',  count: 1 }
          ];
          this.chests = [];
          objs.forEach(o => {
            const ix = o.x / this.tileW;
            const iy = o.y / this.tileH;
            const sx = (ix - iy) * (this.tileW / 2) + this.offsetX;
            const sy = (ix + iy) * (this.tileH / 2) + this.offsetY;
            if (o.type === 'Chest') {
              const chest = this.add.image(sx, sy, 'chest')
                .setOrigin(0.5, 1)
                .setDepth(sy)
                .setInteractive();
              chest.inventory = [];
              chest.on('pointerdown', () => {
                this.openInventory(this.playerInv, chest.inventory);
                this.scene.pause();
              });
              this.chests.push(chest);
            }
            // NPCs and other objects get handled by NPCManager below
          });

          // Player
          this.player = this.add.sprite(0, 0, 'player').setOrigin(0.5, 1);
          this.createPlayerAnims();
          this.playerIsoX = spawnObj.x / this.tileW;
          this.playerIsoY = spawnObj.y / this.tileH;
          const px = (this.playerIsoX - this.playerIsoY) * (this.tileW / 2) + this.offsetX;
          const py = (this.playerIsoX + this.playerIsoY) * (this.tileH / 2) + this.offsetY;
          this.player.setPosition(px, py).setDepth(py);

          this.keys = this.input.keyboard.addKeys('W,A,S,D');
          this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
          this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

          // ——————————————————————————
          // Spawn a group of slimes
          // ——————————————————————————
          this.enemies = this.add.group();
          // Example: spawn one level‐1 slime at tile (5,5):
          const slime = new Enemy(this, 5, 5, 'slime', 1);
          this.enemies.add(slime);

          // Managers
          this.npcManager   = new NPCManager(this);
          this.npcManager.createFromObjects(objs);
          this.questManager = new QuestManager(this);
          this.dialogueTree = new DialogueTreeManager(this);
          this.tradeManager = new TradeManager(this);

          // 1) Load each NPC's main dialogue tree:
          this.npcManager.npcs.forEach(npc => {
            import(`./assets/js/dialogues/${npc.npcId}-tree.js`)
              .then(mod => this.dialogueTree.registerTree(npc.npcId, mod.default))
              .catch(err => console.warn(`No dialogue module for ${npc.npcId}`, err));
          });

          // 2) Load each quest dialogue tree:
          this.questManager.quests.forEach(quest => {
            if (!quest.dialogueFile) return;
            import(`./assets/js/dialogues/${quest.dialogueFile}`)
              .then(mod => {
                this.dialogueTree.registerTree(quest.id, mod.default);
              })
              .catch(err => console.warn(`Failed to load quest tree for ${quest.id}`, err));
          });

          // Conversation & interactions
          this.npcManager.enableConversations('F', npc => {
            this.dialogueTree.startDialogue(npc.npcId);
          });

          // Inventory & Equipment keys
          this.events.on('inventoryClosed', data => {
            this.playerInv = data.playerInv;
            this.scene.resume();
          });
          this.events.on('equipmentChanged', data => {
            this.playerInv = data.playerInv;
            this.equipped  = data.equipped;
            this.scene.resume();
          });
          this.input.keyboard.on('keydown-I', () => {
            this.openInventory(this.playerInv, null);
            this.scene.pause();
          });
          this.input.keyboard.on('keydown-E', () => {
            this.openEquipment(this.playerInv, this.equipped);
            this.scene.pause();
          });

          // Attack input
          this.input.on('pointerdown',   () => this.playerAttack());
          this.input.keyboard.on('keydown-SPACE', () => this.playerAttack());
        }

        createPlayerAnims() {
          [
            ['down', 0, 3],
            ['left', 12, 15],
            ['right', 24, 27],
            ['up', 36, 39],
            ['down-left', 48, 51],
            ['down-right', 60, 63],
            ['up-left', 72, 75],
            ['up-right', 84, 87]
          ].forEach(([k, s, e]) => {
            this.anims.create({
              key: `walk-${k}`,
              frames: this.anims.generateFrameNumbers('player', { start: s, end: e }),
              frameRate: 8,
              repeat: -1
            });
          });
        }

        playerAttack() {
          // Flash to an “attack” frame, e.g. index 92
          this.player.setFrame(92);
          this.time.delayedCall(100, () => {
            const dir = this.lastDir || 'down';
            const idleFrame = { down: 0, left: 12, right: 24, up: 36 }[dir];
            this.player.setFrame(idleFrame);
          });

          const DAMAGE = 1;
          this.enemies.getChildren().forEach(enemy => {
            const dx = enemy.isoX - this.playerIsoX;
            const dy = enemy.isoY - this.playerIsoY;
            const dist = Math.abs(dx) + Math.abs(dy);
            if (dist < 1.5) {
              enemy.takeDamage(DAMAGE);
            }
          });
        }

        update(time, delta) {
          // Player movement
          const dt = delta / 1000,
                speed = 3;
          let moved = false,
              dir   = this.lastDir || 'down';
          let nx = this.playerIsoX,
              ny = this.playerIsoY;
          const { W, A, S, D } = this.keys;

          if (W.isDown) {
            ny -= speed * dt;
            dir = 'up';
            moved = true;
            this.player.play('walk-up', true);
          } else if (S.isDown) {
            ny += speed * dt;
            dir = 'down';
            moved = true;
            this.player.play('walk-down', true);
          }
          if (A.isDown) {
            nx -= speed * dt;
            dir = 'left';
            moved = true;
            this.player.play('walk-left', true);
          } else if (D.isDown) {
            nx += speed * dt;
            dir = 'right';
            moved = true;
            this.player.play('walk-right', true);
          }

          const tx = Math.floor(nx),
                ty = Math.floor(ny);
          if (
            nx >= 0 && nx < this.mapW &&
            ny >= 0 && ny < this.mapH &&
            this.floorData[ty][tx] && !this.collisionData[ty][tx]
          ) {
            this.playerIsoX = nx;
            this.playerIsoY = ny;
          }

          if (!moved) {
            this.player.anims.stop();
            this.player.setFrame({ down: 0, left: 12, right: 24, up: 36 }[dir]);
          }
          this.lastDir = dir;

          const sx = (this.playerIsoX - this.playerIsoY) * (this.tileW / 2) + this.offsetX;
          const sy = (this.playerIsoX + this.playerIsoY) * (this.tileH / 2) + this.offsetY;
          this.player.setPosition(sx, sy).setDepth(sy);

          // Update all enemies
          this.enemies.getChildren().forEach(e => e.update(time, delta));
        }

        openInventory(playerInv, chestInv) {
          this.scene.launch('InventoryScene', { playerInv, chestInv });
        }
        openEquipment(playerInv, equipped) {
          this.scene.launch('EquipmentScene', { playerInv, equipped });
        }
      }

      // Dialogue Scene
      class DialogueScene extends Phaser.Scene {
        constructor() { super('DialogueScene'); }
        init(data) { this.lines = data.lines || []; }
        create() {
          const w = this.scale.width,
                h = this.scale.height;
          const pad = 20;
          const boxW = w / 2,
                boxH = h / 4,
                boxX = w / 4,
                boxY = h / 4;
          this.add.graphics()
            .fillStyle(0x000000, 0.7)
            .fillRect(boxX, boxY, boxW, boxH);

          const textStyle = { fontSize: '18px', fill: '#fff', wordWrap: { width: boxW - pad * 2 } };
          this.lines.forEach((line, i) => {
            this.add.text(boxX + pad, boxY + pad + i * 24, line, textStyle);
          });

          const closeDialog = () => {
            this.scene.stop('DialogueScene');
            this.scene.resume('Main');
            this.scene.get('Main').events.emit('dialogueClosed');
          };
          this.input.keyboard.once('keydown-ESC', closeDialog);
          this.input.once('pointerdown', closeDialog);
        }
      }

      // Choice Scene
      class ChoiceScene extends Phaser.Scene {
        constructor() { super('ChoiceScene'); }
        init(data) {
          this.question = data.question;
          this.options  = data.options || [];
          this.callback = data.callback;
        }
        create() {
          const w = this.scale.width,
                h = this.scale.height;
          const pad = 20;
          const boxW = w / 2,
                boxH = h / 4,
                boxX = w / 4,
                boxY = h / 4;
          this.add.graphics()
            .fillStyle(0x000000, 0.7)
            .fillRect(boxX, boxY, boxW, boxH);

          const textStyle = { fontSize: '18px', fill: '#fff', wordWrap: { width: boxW - pad * 2 } };
          this.add.text(boxX + pad, boxY + pad, this.question, textStyle);

          this.options.forEach((opt, idx) => {
            const txt = this.add.text(
              boxX + pad * 2,
              boxY + pad * 2 + 30 + idx * 30,
              opt,
              { fontSize: '16px', fill: '#ff0' }
            ).setInteractive();
            txt.on('pointerdown', () => {
              if (this.callback) this.callback(idx);
              this.scene.stop('ChoiceScene');
              this.scene.resume('Main');
            });
          });
        }
      }

      // Trade Scene (placeholder UI)
      class TradeScene extends Phaser.Scene {
        constructor() { super('TradeScene'); }
        init(data) {
          this.npcId = data.npcId;
        }
        create() {
          const w = this.scale.width,
                h = this.scale.height;
          const pad = 20;
          const boxW = w / 2,
                boxH = h / 2,
                boxX = w / 4,
                boxY = h / 4;
          this.add.graphics()
            .fillStyle(0x000000, 0.8)
            .fillRect(boxX, boxY, boxW, boxH);

          const textStyle = { fontSize: '18px', fill: '#fff', wordWrap: { width: boxW - pad * 2 } };
          this.add.text(boxX + pad, boxY + pad, `Trading with ${this.npcId}`, textStyle);

          this.input.keyboard.once('keydown-ESC', () => {
            this.scene.stop('TradeScene');
            this.scene.resume('Main');
          });
        }
      }

      const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH
        },
        physics: { default: 'arcade' },
        scene: [
          BootScene,
          PreloadScene,
          MainScene,
          DialogueScene,
          ChoiceScene,
          TradeScene,
          InventoryScene,
          EquipmentScene
        ]
      };

      new Phaser.Game(config);
    });
  </script>
</body>
</html>
