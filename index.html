<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TowerStory</title>
  <style>
    html, body { height:100%; margin:0; padding:0; background:url('assets/images/background.png') center/cover no-repeat; }
    body { display:grid; grid-template-rows:80px auto 60px; grid-template-columns:200px auto 200px; grid-template-areas:"header header header" "sidebar-left main sidebar-right" "footer footer footer"; }
    #header { grid-area: header; }
    #sidebar-left { grid-area: sidebar-left; }
    #game-container { grid-area: main; position:relative; width:100%; height:100%; overflow:hidden; }
    #sidebar-right { grid-area: sidebar-right; }
    #footer { grid-area: footer; }
    #game-container canvas { display:block; margin:auto; }
  </style>
</head>
<body>
  <div id="header"></div>
  <div id="sidebar-left"></div>
  <div id="game-container"></div>
  <div id="sidebar-right"></div>
  <div id="footer"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    window.addEventListener('load', () => {
      class BootScene extends Phaser.Scene {
        constructor() { super('Boot'); }
        create() { this.scene.start('Preload'); }
      }

      class PreloadScene extends Phaser.Scene {
        constructor() { super('Preload'); }
        preload() {
          this.load.tilemapTiledJSON('room', 'assets/maps/room.json');
          this.load.spritesheet('tileset', 'assets/tiles/tileset.png', { frameWidth:38, frameHeight:38 });
          this.load.spritesheet('player', 'assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png', { frameWidth:32, frameHeight:32 });
          this.load.image('chest', 'assets/objects/chest.png');
          this.load.image('npc', 'assets/objects/npc.png');
          this.load.image('potion', 'assets/icons/potion.png');
          this.load.image('sword', 'assets/icons/sword.png');
          this.load.image('coin', 'assets/icons/coin.png');
        }
        create() { this.scene.start('Main'); }
      }

      class MainScene extends Phaser.Scene {
        constructor() { super('Main'); }
        create() {
          const map = this.make.tilemap({ key: 'room' });
          // Store map and tile dimensions
          this.tileW = map.tileWidth;
          this.tileH = map.tileHeight;
          this.mapW = map.width;
          this.mapH = map.height;
          const tileset = map.addTilesetImage('tileset', 'tileset', map.tileWidth, map.tileHeight);
          // Floor
          this.offsetX = this.scale.width / 2;
          this.offsetY = (this.scale.height - (map.width + map.height) * (map.tileHeight / 2)) / 2 + map.tileHeight/2;
          this.floorData = map.getLayer('Floor').data.map(r => r.map(t => t.index > 0));
          this.collisionData = map.getLayer('Collision').data.map(r => r.map(t => t.index > 0));
          map.getLayer('Floor').data.forEach((row, y) => {
            row.forEach((tile, x) => {
              if (tile.index > 0) {
                const frame = tile.index - 1;
                const sx = (x - y) * (map.tileWidth / 2) + this.offsetX;
                const sy = (x + y) * (map.tileHeight / 2) + this.offsetY;
                this.add.image(sx, sy, 'tileset', frame).setDepth(sy);
              }
            });
          });
          // Objects
          const objLayer = map.getObjectLayer('Objects');
          const spawn = map.findObject('Objects', o => o.name === 'PlayerSpawn');
          objLayer.objects.push({ name:'Chest1', type:'Chest', x: spawn.x + map.tileWidth*2, y: spawn.y, visible:true });
          objLayer.objects.push({ name:'NPC1',   type:'NPC',   x: spawn.x - map.tileWidth*2, y: spawn.y, visible:true });

          this.playerInv = [{ iconKey:'potion', count:3 },{ iconKey:'sword', count:1 }];
          this.chests = [];
          objLayer.objects.forEach(o => {
            const ix = o.x / map.tileWidth, iy = o.y / map.tileHeight;
            const sx = (ix - iy) * (map.tileWidth / 2) + this.offsetX;
            const sy = (ix + iy) * (map.tileHeight / 2) + this.offsetY;
            if (o.type === 'Chest') {
              const chest = this.add.image(sx, sy, 'chest').setOrigin(0.5,1).setDepth(sy).setInteractive();
              chest.inventory = [{ iconKey:'coin', count:2 },{ iconKey:'potion', count:1 }];
              chest.on('pointerdown', () => {
                this.scene.pause();
                this.scene.launch('InventoryScene', { playerInv: this.playerInv, chestInv: chest.inventory });
              });
              this.chests.push(chest);
            } else if (o.type === 'NPC') {
              this.add.image(sx, sy, 'npc').setOrigin(0.5,1).setDepth(sy);
            }
          });
          // Player
          this.player = this.add.sprite(0,0,'player').setOrigin(0.5,1);
          this.createPlayerAnims();
          this.playerIsoX = spawn.x/map.tileWidth;
          this.playerIsoY = spawn.y/map.tileHeight;
          this.keys = this.input.keyboard.addKeys('W,A,S,D');
          this.cameras.main.setBounds(0,0,map.widthInPixels,map.heightInPixels);
          this.cameras.main.startFollow(this.player,true,0.1,0.1);
          this.events.on('inventoryClosed', data => {
            this.playerInv = data.playerInv;
            this.chests[0].inventory = data.chestInv;
            this.scene.resume();
          });
        }
        update(t, d) {
          const dt = d / 1000;
          const speed = 3;
          let moved = false;
          let dir = this.lastDir || 'down';
          let nx = this.playerIsoX;
          let ny = this.playerIsoY;
          const { W, A, S, D } = this.keys;
          if (W.isDown) { ny -= speed * dt; dir = 'up'; moved = true; this.player.play('walk-up', true); }
          else if (S.isDown) { ny += speed * dt; dir = 'down'; moved = true; this.player.play('walk-down', true); }
          if (A.isDown) { nx -= speed * dt; dir = 'left'; moved = true; this.player.play('walk-left', true); }
          else if (D.isDown) { nx += speed * dt; dir = 'right'; moved = true; this.player.play('walk-right', true); }
          const tx = Math.floor(nx);
          const ty = Math.floor(ny);
          if (nx >= 0 && nx < this.mapW && ny >= 0 && ny < this.mapH && this.floorData[ty][tx] && !this.collisionData[ty][tx]) {
            this.playerIsoX = nx;
            this.playerIsoY = ny;
          }
          if (!moved) {
            this.player.anims.stop();
            this.player.setFrame({ down: 0, left: 12, right: 24, up: 36 }[dir]);
          }
          this.lastDir = dir;
          const sx = (this.playerIsoX - this.playerIsoY) * (this.tileW / 2) + this.offsetX;
          const sy = (this.playerIsoX + this.playerIsoY) * (this.tileH / 2) + this.offsetY;
          this.player.setPosition(sx, sy).setDepth(sy);
        }
        createPlayerAnims(){
          [['down',0,3],['left',12,15],['right',24,27],['up',36,39],['down-left',48,51],['down-right',60,63],['up-left',72,75],['up-right',84,87]].forEach(([k,s,e])=>{
            this.anims.create({ key:`walk-${k}`, frames:this.anims.generateFrameNumbers('player',{start:s,end:e}), frameRate:8, repeat:-1 });
          });
        }
      }

      class InventoryScene extends Phaser.Scene {
        constructor(){ super('InventoryScene'); }
        init(data){ this.playerInv = data.playerInv; this.chestInv = data.chestInv; }
        create(){
          const w = this.scale.width;
          this.pw = 200; this.ph = 300;
          this.leftPanel  = new Phaser.Geom.Rectangle(50,50,this.pw,this.ph);
          this.rightPanel = new Phaser.Geom.Rectangle(w-50-this.pw,50,this.pw,this.ph);
          this.uiGroup = this.add.group();

          // Zones for dragging panels
          this.leftZone  = this.add.zone(this.leftPanel.x,this.leftPanel.y,this.pw,20).setOrigin(0).setInteractive();
          this.rightZone = this.add.zone(this.rightPanel.x,this.rightPanel.y,this.pw,20).setOrigin(0).setInteractive();
          this.input.setDraggable([this.leftZone,this.rightZone]);

          // Drag events
          this.input.on('dragstart', (pointer, obj) => {
            if (obj !== this.leftZone && obj !== this.rightZone) obj.setDepth(1000);
          });

          this.input.on('drag', (pointer, obj, dx, dy) => {
            if (obj === this.leftZone) {
              this.leftPanel.x = dx;
              this.leftZone.x = dx;
              this.leftPanel.y = dy;
              this.leftZone.y = dy;
              this.redraw();
            } else if (obj === this.rightZone) {
              this.rightPanel.x = dx;
              this.rightZone.x = dx;
              this.rightPanel.y = dy;
              this.rightZone.y = dy;
              this.redraw();
            } else {
              // Dragging an item
              obj.x = dx;
              obj.y = dy;
            }
          });

          this.input.on('dragend', this.onDragEnd, this);
          this.input.keyboard.on('keydown-I', () => {
            // Toggle inventory scene
            if (this.scene.isActive('InventoryScene')) this.close();
          });

          this.redraw();
        }

        redraw(){
          this.uiGroup.clear(true,true);
          const g = this.add.graphics().fillStyle(0x222222,0.8);
          g.fillRectShape(this.leftPanel).fillRectShape(this.rightPanel);
          // Title bars darker
          g.fillStyle(0x333333,1).fillRect(this.leftPanel.x,this.leftPanel.y,this.pw,20)
                           .fillRect(this.rightPanel.x,this.rightPanel.y,this.pw,20);
          this.uiGroup.add(g);
          // Titles
          const t1 = this.add.text(this.leftPanel.x+10,this.leftPanel.y+4,'Inventory',{fontSize:'16px',fill:'#fff'}).setDepth(1);
          const t2 = this.add.text(this.rightPanel.x+10,this.rightPanel.y+4,'Chest',{fontSize:'16px',fill:'#fff'}).setDepth(1);
          this.uiGroup.addMultiple([t1,t2]);
          // Slots
          this.drawSlots(this.leftPanel,this.playerInv,'player');
          this.drawSlots(this.rightPanel,this.chestInv,'chest');
        }

        drawSlots(panel,arr,source){
          const cols=4, rows=5;
          arr.forEach((it,i)=>{
            const cnt = it.count||1;
            const col = i % cols;
            const row = Math.floor(i/cols);
            if (row>=rows) return;
            const x = panel.x+10 + col*48;
            const y = panel.y+40 + row*48;
            const slot = this.add.rectangle(x,y,44,44,0x444444).setOrigin(0);
            const icon = this.add.image(x+22,y+22,it.iconKey)
                              .setInteractive({draggable:true})
                              .setData('source',source)
                              .setData('index',i);
            this.uiGroup.addMultiple([slot, icon]);
            if (cnt>1) {
              const cntT = this.add.text(x+32,y+32,cnt+'',{fontSize:'12px',fill:'#fff'}).setOrigin(1);
              this.uiGroup.add(cntT);
            }
          });
        }

        onDragEnd(pointer, icon){
          const source = icon.getData('source');
          if (!source) return;
          const idx = icon.getData('index');
          const srcArr = source==='player'?this.playerInv:this.chestInv;
          if (idx<0||idx>=srcArr.length) return;
          const dstArr = source==='player'?this.chestInv:this.playerInv;
          const dstPanel = source==='player'?this.rightPanel:this.leftPanel;
          const x=pointer.x, y=pointer.y;
          if (dstPanel.contains(x,y)){
            const item=srcArr[idx];
            const ex = dstArr.find(i=>i.iconKey===item.iconKey);
            if (ex) ex.count += item.count||1;
            else if (dstArr.length<20) dstArr.push({iconKey:item.iconKey,count:item.count||1});
            srcArr.splice(idx,1);
          }
          this.redraw();
        }

        close(){
          this.scene.get('Main').events.emit('inventoryClosed', { playerInv:this.playerInv, chestInv:this.chestInv });
          this.scene.stop();
        }
      }

      const config={ type:Phaser.AUTO, parent:'game-container', scale:{mode:Phaser.Scale.FIT,autoCenter:Phaser.Scale.CENTER_BOTH}, physics:{default:'arcade'}, scene:[BootScene,PreloadScene,MainScene,InventoryScene] };
      new Phaser.Game(config);
    });
  <\/script>
<\/body>
<\/html>
