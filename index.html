<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TowerStory</title>
  <style>
    html, body { height:100%; width:100%; margin:0; padding:0; background: url('assets/images/background.png') center/cover no-repeat; }
    body { display:grid; grid-template-rows:80px auto 60px; grid-template-columns:200px auto 200px;
      grid-template-areas:"header header header" "sidebar-left main sidebar-right" "footer footer footer";
      align-items:center; justify-items:center; }
    #header{grid-area:header;} #sidebar-left{grid-area:sidebar-left;} #sidebar-right{grid-area:sidebar-right;} #footer{grid-area:footer;}
    #game-container{grid-area:main; display:flex; align-items:center; justify-content:center; width:100%; height:100%; overflow:hidden;}
    #game-container canvas{max-width:100%; max-height:100%;}
  </style>
</head>
<body>
  <div id="header"></div>
  <div id="sidebar-left"></div>
  <div id="game-container"></div>
  <div id="sidebar-right"></div>
  <div id="footer"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    window.addEventListener('load', () => {
      class BootScene extends Phaser.Scene {
        constructor() { super('Boot'); }
        create() { this.scene.start('Preload'); }
      }

      class PreloadScene extends Phaser.Scene {
        constructor() { super('Preload'); }
        preload() {
          this.load.tilemapTiledJSON('room', 'assets/maps/room.json');
          this.load.spritesheet('tileset', 'assets/tiles/tileset.png', { frameWidth: 38, frameHeight: 38 });
          this.load.spritesheet('player', 'assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png', { frameWidth: 32, frameHeight: 32 });
        }
        create() { this.scene.start('Main'); }
      }

      class MainScene extends Phaser.Scene {
        constructor() { super('Main'); }
        create() {
          const map = this.make.tilemap({ key: 'room' });
          // Store tile dimensions
          this.tileW = map.tileWidth;
          this.tileH = map.tileHeight;
          // Initialize map dimensions
          this.mapW = map.width;
          this.mapH = map.height;
          // Add tileset
          map.addTilesetImage('tileset', 'tileset', this.tileW, this.tileH, 0, 0);

          // Manual isometric floor rendering
          this.offsetX = this.scale.width / 2;
          this.offsetY = (this.scale.height - (this.mapW + this.mapH) * (this.tileH / 2)) / 2 + (this.tileH / 2);
          this.floorData = map.getLayer('Floor').data.map(row => row.map(t => !!t && t.index > 0));
          this.collisionData = map.getLayer('Collision').data.map(row => row.map(t => !!t && t.index > 0));
          this.floorSprites = this.add.group();
          for (let y = 0; y < this.mapH; y++) {
            for (let x = 0; x < this.mapW; x++) {
              if (this.floorData[y][x]) {
                const frame = map.getLayer('Floor').data[y][x].index - 1;
                const sx = (x - y) * (this.tileW / 2) + this.offsetX;
                const sy = (x + y) * (this.tileH / 2) + this.offsetY;
                this.floorSprites.add(this.add.sprite(sx, sy, 'tileset', frame).setDepth(sy));
              }
            }
          }

          // Spawn player at object position
          const spawn = map.findObject('Objects', o => o.name === 'PlayerSpawn');
          this.playerIsoX = spawn.x / this.tileW;
          this.playerIsoY = spawn.y / this.tileH;
          this.player = this.add.sprite(0, 0, 'player').setOrigin(0.5, 1);
          this.updatePlayerPosition();

          // Animations
          [['down',0,3],['left',12,15],['right',24,27],['up',36,39],['down-left',48,51],['down-right',60,63],['up-left',72,75],['up-right',84,87]].forEach(([k,s,e])=>{
            this.anims.create({ key: `walk-${k}`, frames: this.anims.generateFrameNumbers('player',{start:s,end:e}), frameRate:8, repeat:-1 });
          });

          this.keys = this.input.keyboard.addKeys('W,A,S,D');
          const cam = this.cameras.main;
          cam.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
          cam.startFollow(this.player, true, 0.1, 0.1);
        }

        update(time, delta) {
          const dt = delta / 1000;
          const speed = 3;
          let moved = false;
          let dir = this.lastDir || 'down';
          let nx = this.playerIsoX;
          let ny = this.playerIsoY;
          const { W, A, S, D } = this.keys;
          if (W.isDown) { ny -= speed * dt; dir = 'up'; moved = true; this.player.play('walk-up', true); }
          else if (S.isDown) { ny += speed * dt; dir = 'down'; moved = true; this.player.play('walk-down', true); }
          if (A.isDown) { nx -= speed * dt; dir = 'left'; moved = true; this.player.play('walk-left', true); }
          else if (D.isDown) { nx += speed * dt; dir = 'right'; moved = true; this.player.play('walk-right', true); }

          // Collision and boundary test
          if (nx >= 0 && nx < this.mapW && ny >= 0 && ny < this.mapH) {
            const tx = Math.floor(nx), ty = Math.floor(ny);
            if (this.floorData[ty][tx] && !this.collisionData[ty][tx]) {
              this.playerIsoX = nx;
              this.playerIsoY = ny;
            }
          }

          if (!moved) {
            this.player.anims.stop();
            const idle = { down:0, left:12, right:24, up:36 }[dir];
            this.player.setFrame(idle);
          }
          this.lastDir = dir;
          this.updatePlayerPosition();
        }

        updatePlayerPosition() {
          const x = this.playerIsoX, y = this.playerIsoY;
          const sx = (x - y) * (this.tileW / 2) + this.offsetX;
          const sy = (x + y) * (this.tileH / 2) + this.offsetY;
          this.player.setPosition(sx, sy).setDepth(sy);
        }
      }

      const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
        physics: { default: 'arcade' },
        scene: [BootScene, PreloadScene, MainScene]
      };
      new Phaser.Game(config);
    });
  </script>
</body>
</html>
