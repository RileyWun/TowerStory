<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TowerStory</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; }
    #game-container { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <!-- Phaser 3 -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <!-- Phaser Isometric Plugin -->
  <script src="https://cdn.jsdelivr.net/npm/phaser3-plugin-isometric/dist/phaser3-plugin-isometric.min.js"></script>

  <!-- Game Code -->
  <script>
    // Configuration
    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      width: 800,
      height: 600,
      backgroundColor: '#1d212d',
      scene: [BootScene, PreloadScene, MainScene],
      plugins: {
        scene: [
          { key: 'IsoPlugin', plugin: PhaserIsoPlugin, mapping: 'iso' }
        ]
      }
    };

    // Create game instance
    const game = new Phaser.Game(config);

    // Boot Scene
    class BootScene extends Phaser.Scene {
      constructor() { super('Boot'); }
      preload() {
        // assets for preload UI if any
      }
      create() {
        this.scene.start('Preload');
      }
    }

    // Preload Scene
    class PreloadScene extends Phaser.Scene {
      constructor() { super('Preload'); }
      preload() {
        // Load tile image (e.g., a simple square or tile texture)
        this.load.image('tile', 'assets/tiles/tile.png');
      }
      create() {
        this.scene.start('Main');
      }
    }

    // Main Scene
    class MainScene extends Phaser.Scene {
      constructor() { super('Main'); }
      create() {
        // Create a group for sorting
        this.isoGroup = this.add.group();

        // Generate a simple isometric grid
        const tileSize = 38;
        const mapWidth = 20;
        const mapHeight = 20;
        for (let x = 0; x < mapWidth; x++) {
          for (let y = 0; y < mapHeight; y++) {
            // position in iso coordinates
            const isoX = x * tileSize;
            const isoY = y * tileSize;
            const tile = this.iso.add.isoSprite(isoX, isoY, 0, 'tile');
            tile.setDepth(tile.y);
            this.isoGroup.add(tile);
          }
        }

        // Camera setup
        const worldWidth = mapWidth * tileSize;
        const worldHeight = mapHeight * tileSize;
        this.cameras.main.setBounds(0, 0, worldWidth, worldHeight);
        this.cameras.main.centerOn(worldWidth / 2, worldHeight / 2);

        // Enable camera drag
        this.input.on('pointerdown', () => { this.dragging = true; });
        this.input.on('pointerup', () => { this.dragging = false; });
        this.input.on('pointermove', (pointer) => {
          if (this.dragging) {
            const cam = this.cameras.main;
            cam.scrollX -= (pointer.x - pointer.prevPosition.x) / cam.zoom;
            cam.scrollY -= (pointer.y - pointer.prevPosition.y) / cam.zoom;
          }
        });

        // Arrow key panning
        this.cursors = this.input.keyboard.createCursorKeys();
      }

      update(time, delta) {
        // Depth sort
        this.isoGroup.getChildren().sort((a, b) => a.y - b.y);

        // Camera move speed
        const speed = 300;
        const cam = this.cameras.main;
        if (this.cursors.left.isDown)  cam.scrollX -= speed * delta / 1000;
        if (this.cursors.right.isDown) cam.scrollX += speed * delta / 1000;
        if (this.cursors.up.isDown)    cam.scrollY -= speed * delta / 1000;
        if (this.cursors.down.isDown)  cam.scrollY += speed * delta / 1000;
      }
    }
  </script>
</body>
</html>
