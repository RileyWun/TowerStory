<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TowerStory</title>
  <style>
    html, body { height:100%; margin:0; padding:0; background:url('assets/images/background.png') center/cover no-repeat; }
    body { display:grid; grid-template-rows:80px auto 60px; grid-template-columns:200px auto 200px; grid-template-areas:"header header header" "sidebar-left main sidebar-right" "footer footer footer"; align-items:center; justify-items:center; }
    #header { grid-area: header; }
    #sidebar-left { grid-area: sidebar-left; }
    #sidebar-right { grid-area: sidebar-right; }
    #footer { grid-area: footer; }
    #game-container { grid-area: main; position: relative; width:100%; height:100%; overflow:hidden; display:flex; align-items:center; justify-content:center; }
    #game-container canvas { width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="header"></div>
  <div id="sidebar-left"></div>
  <div id="game-container"></div>
  <div id="sidebar-right"></div>
  <div id="footer"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    window.addEventListener('load', () => {
      // Boot Scene
      class BootScene extends Phaser.Scene {
        constructor() { super('Boot'); }
        create() { this.scene.start('Preload'); }
      }

      // Preload assets
      class PreloadScene extends Phaser.Scene {
        constructor() { super('Preload'); }
        preload() {
          this.load.tilemapTiledJSON('room', 'assets/maps/room.json');
          // Load the tileset as a spritesheet for correct frame slicing
          this.load.spritesheet('tileset', 'assets/tiles/tileset.png', { frameWidth:38, frameHeight:38 });
          this.load.spritesheet('player','assets/player/Chibi-character-template_skin0_part2_by_AxulArt.png',{ frameWidth:32, frameHeight:32 });
          this.load.image('chest','assets/objects/chest.png');
          this.load.image('npc','assets/objects/npc.png');
          this.load.image('potion','assets/icons/potion.png');
          this.load.image('sword','assets/icons/sword.png');
          this.load.image('coin','assets/icons/coin.png');
        }
        create() { this.scene.start('Main'); }
      }

      // Main game scene
      class MainScene extends Phaser.Scene {
        constructor() { super('Main'); }
        create() {
          const map = this.make.tilemap({ key: 'room' });
          this.tileW = map.tileWidth; this.tileH = map.tileHeight;
          this.mapW = map.width; this.mapH = map.height;
          const tileset = map.addTilesetImage('tileset', 'tileset', this.tileW, this.tileH);

          // Render floor
          this.offsetX = this.scale.width/2;
          this.offsetY = (this.scale.height - (this.mapW + this.mapH)*(this.tileH/2))/2 + this.tileH/2;
          this.floorData = map.getLayer('Floor').data.map(row => row.map(t => !!t && t.index > 0));
          this.collisionData = map.getLayer('Collision').data.map(row => row.map(t => !!t && t.index > 0));
          this.floorGroup = this.add.group();
          map.getLayer('Floor').data.forEach((row, y) => {
            row.forEach((t, x) => {
              if (t.index > 0) {
                const frame = t.index - 1;
                const sx = (x - y)*(this.tileW/2) + this.offsetX;
                const sy = (x + y)*(this.tileH/2) + this.offsetY;
                this.floorGroup.add(this.add.image(sx, sy, 'tileset', frame).setDepth(sy));
              }
            });
          });

          // Spawn objects
          const objectLayer = map.getObjectLayer('Objects');
          const spawn = map.findObject('Objects', o => o.name === 'PlayerSpawn');
          objectLayer.objects.push({ name:'Chest1', type:'Chest', x:spawn.x + this.tileW*2, y:spawn.y, visible:true });
          objectLayer.objects.push({ name:'NPC1', type:'NPC', x:spawn.x - this.tileW*2, y:spawn.y, visible:true });
          this.chests = [];
          objectLayer.objects.forEach(o => {
            const ix = o.x/this.tileW, iy = o.y/this.tileH;
            const sx = (ix - iy)*(this.tileW/2) + this.offsetX;
            const sy = (ix + iy)*(this.tileH/2) + this.offsetY;
            if (o.type === 'Chest') {
              const chest = this.add.image(sx, sy, 'chest').setOrigin(0.5,1).setDepth(sy).setInteractive();
              chest.inventory = [{ iconKey:'coin', count:2 },{ iconKey:'potion', count:1 }];
              chest.on('pointerdown', () => {
                this.scene.pause();
                this.scene.launch('InventoryScene', { playerInv:this.playerInv, chestInv:chest.inventory });
              });
              this.chests.push(chest);
            } else if (o.type === 'NPC') {
              this.add.image(sx, sy, 'npc').setOrigin(0.5,1).setDepth(sy);
            }
          });

          // Player
          this.playerInv = [{ iconKey:'potion', count:3 },{ iconKey:'sword', count:1 }];
          this.player = this.add.sprite(0,0,'player').setOrigin(0.5,1);
          this.player.inventory = this.playerInv;
          this.createPlayerAnims();
          this.playerIsoX = spawn.x/this.tileW;
          this.playerIsoY = spawn.y/this.tileH;
          this.updatePlayerPosition();
          this.keys = this.input.keyboard.addKeys('W,A,S,D');
          const cam = this.cameras.main;
          cam.setBounds(0,0,map.widthInPixels,map.heightInPixels);
          cam.startFollow(this.player,true,0.1,0.1);
          this.events.on('inventoryClosed', data => {
            this.playerInv = data.playerInv;
            this.chests[0].inventory = data.chestInv;
            this.scene.resume();
          });
        }
        update(time, delta) {
          const dt = delta/1000, speed = 3;
          let moved = false, dir = this.lastDir || 'down';
          let nx = this.playerIsoX, ny = this.playerIsoY;
          const { W,A,S,D } = this.keys;
          if (W.isDown){ ny -= speed*dt; dir='up'; moved=true; this.player.play('walk-up',true);} else if (S.isDown){ ny += speed*dt; dir='down'; moved=true; this.player.play('walk-down',true);} 
          if (A.isDown){ nx -= speed*dt; dir='left'; moved=true; this.player.play('walk-left',true);} else if (D.isDown){ nx += speed*dt; dir='right'; moved=true; this.player.play('walk-right',true);} 
          if (nx>=0&&nx<this.mapW&&ny>=0&&ny<this.mapH){ const tx=Math.floor(nx), ty=Math.floor(ny);
            if (this.floorData[ty][tx] && !this.collisionData[ty][tx]) { this.playerIsoX=nx; this.playerIsoY=ny; }
          }
          if (!moved) { this.player.anims.stop(); this.player.setFrame({down:0,left:12,right:24,up:36}[dir]); }
          this.lastDir = dir;
          this.updatePlayerPosition();
        }
        createPlayerAnims() {
          [['down',0,3],['left',12,15],['right',24,27],['up',36,39],['down-left',48,51],['down-right',60,63],['up-left',72,75],['up-right',84,87]].forEach(([k,s,e])=>{
            this.anims.create({ key:`walk-${k}`, frames:this.anims.generateFrameNumbers('player',{start:s,end:e}), frameRate:8, repeat:-1 });
          });
        }
        updatePlayerPosition() {
          const x=this.playerIsoX, y=this.playerIsoY;
          const sx=(x-y)*(this.tileW/2)+this.offsetX;
          const sy=(x+y)*(this.tileH/2)+this.offsetY;
          this.player.setPosition(sx,sy).setDepth(sy);
        }
      }

      // Inventory scene
      class InventoryScene extends Phaser.Scene {
        constructor(){ super('InventoryScene'); }
        init(data){ this.playerInv=data.playerInv; this.chestInv=data.chestInv; }
        create(){
          const w=this.scale.width, h=this.scale.height;
          this.pw=200; this.ph=300;
          this.leftPanel=new Phaser.Geom.Rectangle(50,50,this.pw,this.ph);
          this.rightPanel=new Phaser.Geom.Rectangle(w-50-this.pw,50,this.pw,this.ph);
          this.graphics=this.add.graphics().fillStyle(0x222222,0.8).fillRectShape(this.leftPanel).fillRectShape(this.rightPanel);
          this.add.text(this.leftPanel.x+10,this.leftPanel.y+10,'Inventory',{fontSize:'16px',fill:'#fff'});
          this.add.text(this.rightPanel.x+10,this.rightPanel.y+10,'Chest',{fontSize:'16px',fill:'#fff'});
          this.drawSlots(this.leftPanel,this.playerInv,'player');
          this.drawSlots(this.rightPanel,this.chestInv,'chest');
          this.leftZone=this.add.zone(this.leftPanel.x,this.leftPanel.y,this.pw,20).setOrigin(0).setInteractive();
          this.rightZone=this.add.zone(this.rightPanel.x,this.rightPanel.y,this.pw,20).setOrigin(0).setInteractive();
          this.input.setDraggable([this.leftZone,this.rightZone]);
          this.input.on('drag',(p,obj,dx,dy)=>{
            if(obj===this.leftZone){ this.leftPanel.x=dx; this.leftZone.x=dx; this.leftPanel.y=dy; this.leftZone.y=dy; }
            else if(obj===this.rightZone){ this.rightPanel.x=dx; this.rightZone.x=dx; this.rightPanel.y=dy; this.rightZone.y=dy; }
            this.redraw();
          });
          this.input.on('dragstart',(p,i)=>i.setDepth(1000));
          this.input.on('drag',(p,i,dx,dy)=>i.setPosition(dx,dy));
          this.input.on('dragend',this.onDragEnd,this);
          this.input.keyboard.on('keydown-ESC',()=>this.close());
        }
        redraw(){ this.graphics.clear().fillStyle(0x222222,0.8).fillRectShape(this.leftPanel).fillRectShape(this.rightPanel); this.drawSlots(this.leftPanel,this.playerInv,'player'); this.drawSlots(this.rightPanel,this.chestInv,'chest'); }
        drawSlots(panel,arr,source){ const cols=4,rows=5; arr.forEach((it,i)=>{ const cnt=it.count||1, c=i%cols, r=Math.floor(i/cols); if(r>=rows)return; const x=panel.x+10+c*48, y=panel.y+40+r*48; this.add.rectangle(x,y,44,44,0x444444).setOrigin(0); const icon=this.add.image(x+22,y+22,it.iconKey).setInteractive({draggable:true}).setData('source',source).setData('index',i); if(cnt>1) this.add.text(x+32,y+32,cnt.toString(),{fontSize:'12px',fill:'#fff'}).setOrigin(1); }); }
        onDragEnd(p,icon){ const x=p.x,y=p.y, from=icon.getData('source'), idx=icon.getData('index'), src=from==='player'?this.playerInv:this.chestInv, dst=from==='player'?this.chestInv:this.playerInv, dstP=from==='player'?this.rightPanel:this.leftPanel; if(dstP.contains(x,y)){ const item=src[idx], ex=dst.find(i=>i.iconKey===item.iconKey); if(ex) ex.count+=item.count||1; else if(dst.length<20) dst.push({iconKey:item.iconKey,count:item.count||1}); src.splice(idx,1);} this.redraw(); }
        close(){ this.scene.get('Main').events.emit('inventoryClosed',{playerInv:this.playerInv,chestInv:this.chestInv}); this.scene.stop(); }
      }

      const config={ type:Phaser.AUTO, parent:'game-container', scale:{mode:Phaser.Scale.FIT,autoCenter:Phaser.Scale.CENTER_BOTH}, physics:{default:'arcade'}, scene:[BootScene,PreloadScene,MainScene,InventoryScene] };
      new Phaser.Game(config);
    });
  </script>
</body>
</html>
